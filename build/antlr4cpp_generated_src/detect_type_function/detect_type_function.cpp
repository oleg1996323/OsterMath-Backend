
// Generated from /home/oster/Electrolisys/grammar/detect_type_function.g4 by ANTLR 4.13.1


#include "detect_type_functionListener.h"

#include "detect_type_function.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct Detect_type_functionStaticData final {
  Detect_type_functionStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  Detect_type_functionStaticData(const Detect_type_functionStaticData&) = delete;
  Detect_type_functionStaticData(Detect_type_functionStaticData&&) = delete;
  Detect_type_functionStaticData& operator=(const Detect_type_functionStaticData&) = delete;
  Detect_type_functionStaticData& operator=(Detect_type_functionStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag detect_type_functionParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
Detect_type_functionStaticData *detect_type_functionParserStaticData = nullptr;

void detect_type_functionParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (detect_type_functionParserStaticData != nullptr) {
    return;
  }
#else
  assert(detect_type_functionParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<Detect_type_functionStaticData>(
    std::vector<std::string>{
      "line_input", "array", "node_access", "variable", "expr", "number", 
      "constant", "function", "multiargfunction", "rangefunction", "string", 
      "string_arg"
    },
    std::vector<std::string>{
      "", "'VAR'", "'['", "']'", "'\"'", "'\\\"'", "", "", "'>'", "", "'='", 
      "", "'<'", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "'('", "')'", "':'", "';'", "'+'", "'-'", "'*'", 
      "'/'", "'^'", "'''"
    },
    std::vector<std::string>{
      "", "VAR_TAG", "BEG_ARR", "END_ARR", "DOUBLE_QUOTE", "ESCAPED_DOUBLE_QUOTE", 
      "VARIABLE", "DATABASE", "LARGER", "LARGER_EQUAL", "EQUAL", "LESS", 
      "LESS_EQUAL", "SUMPRODUCT", "SUMPRODUCT_I", "SUM", "SUM_I", "PRODUCT", 
      "PRODUCT_I", "LN", "LG", "LOG_X", "EXP", "SQRT", "PI", "COS", "SIN", 
      "ASIN", "ACOS", "FACTORIAL", "SEARCH_STRING", "CONTAIN_TEXT", "CONCAT", 
      "WEIBULL_DISTRIB", "GAUSS", "STD_NORM_DISTRIB", "NORM_DISTRIB", "GAMMA", 
      "GAMMA_REV", "ROOT_MEAN_SQUARE", "ROOT_MEAN_SQUARE_ERROR", "AVERAGE", 
      "MEDIAN", "PEARSON", "STRING_ARG", "STRING", "WS", "EOL", "UINT", 
      "Lb", "Rb", "COL", "SEPAR", "ADD", "SUB", "MUL", "DIV", "POW", "QUOTE", 
      "ASTERISK", "EXPONENT", "FLOAT", "ID_NUMBER"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,62,1227,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,1,0,5,0,26,8,0,10,0,12,0,29,
  	9,0,1,0,1,0,5,0,33,8,0,10,0,12,0,36,9,0,1,0,1,0,3,0,40,8,0,1,0,3,0,43,
  	8,0,1,0,1,0,3,0,47,8,0,1,1,1,1,5,1,51,8,1,10,1,12,1,54,9,1,1,1,1,1,3,
  	1,58,8,1,1,1,5,1,61,8,1,10,1,12,1,64,9,1,1,1,1,1,5,1,68,8,1,10,1,12,1,
  	71,9,1,1,1,1,1,3,1,75,8,1,5,1,77,8,1,10,1,12,1,80,9,1,1,1,1,1,1,2,5,2,
  	85,8,2,10,2,12,2,88,9,2,1,2,1,2,5,2,92,8,2,10,2,12,2,95,9,2,1,2,1,2,1,
  	2,5,2,100,8,2,10,2,12,2,103,9,2,1,2,1,2,5,2,107,8,2,10,2,12,2,110,9,2,
  	1,2,1,2,1,2,5,2,115,8,2,10,2,12,2,118,9,2,1,2,1,2,5,2,122,8,2,10,2,12,
  	2,125,9,2,1,2,1,2,5,2,129,8,2,10,2,12,2,132,9,2,1,2,5,2,135,8,2,10,2,
  	12,2,138,9,2,1,2,5,2,141,8,2,10,2,12,2,144,9,2,1,2,1,2,1,2,5,2,149,8,
  	2,10,2,12,2,152,9,2,3,2,154,8,2,1,3,5,3,157,8,3,10,3,12,3,160,9,3,1,3,
  	1,3,1,3,5,3,165,8,3,10,3,12,3,168,9,3,1,3,1,3,1,3,5,3,173,8,3,10,3,12,
  	3,176,9,3,1,3,5,3,179,8,3,10,3,12,3,182,9,3,1,3,1,3,5,3,186,8,3,10,3,
  	12,3,189,9,3,3,3,191,8,3,1,3,1,3,3,3,195,8,3,1,3,1,3,3,3,199,8,3,3,3,
  	201,8,3,1,3,5,3,204,8,3,10,3,12,3,207,9,3,1,4,1,4,1,4,1,4,1,4,1,4,1,4,
  	1,4,1,4,3,4,218,8,4,1,4,1,4,3,4,222,8,4,1,4,1,4,5,4,226,8,4,10,4,12,4,
  	229,9,4,1,4,3,4,232,8,4,1,4,1,4,1,4,1,4,1,4,5,4,239,8,4,10,4,12,4,242,
  	9,4,1,4,1,4,5,4,246,8,4,10,4,12,4,249,9,4,1,4,1,4,1,4,5,4,254,8,4,10,
  	4,12,4,257,9,4,1,4,1,4,5,4,261,8,4,10,4,12,4,264,9,4,1,4,5,4,267,8,4,
  	10,4,12,4,270,9,4,1,5,1,5,1,6,1,6,1,7,5,7,277,8,7,10,7,12,7,280,9,7,1,
  	7,1,7,1,7,5,7,285,8,7,10,7,12,7,288,9,7,1,7,1,7,5,7,292,8,7,10,7,12,7,
  	295,9,7,1,7,1,7,5,7,299,8,7,10,7,12,7,302,9,7,1,7,5,7,305,8,7,10,7,12,
  	7,308,9,7,1,7,1,7,1,7,5,7,313,8,7,10,7,12,7,316,9,7,1,7,1,7,5,7,320,8,
  	7,10,7,12,7,323,9,7,1,7,1,7,5,7,327,8,7,10,7,12,7,330,9,7,1,7,5,7,333,
  	8,7,10,7,12,7,336,9,7,1,7,1,7,1,7,5,7,341,8,7,10,7,12,7,344,9,7,1,7,1,
  	7,5,7,348,8,7,10,7,12,7,351,9,7,1,7,1,7,5,7,355,8,7,10,7,12,7,358,9,7,
  	1,7,5,7,361,8,7,10,7,12,7,364,9,7,1,7,1,7,1,7,5,7,369,8,7,10,7,12,7,372,
  	9,7,1,7,1,7,5,7,376,8,7,10,7,12,7,379,9,7,1,7,1,7,5,7,383,8,7,10,7,12,
  	7,386,9,7,1,7,5,7,389,8,7,10,7,12,7,392,9,7,1,7,1,7,1,7,5,7,397,8,7,10,
  	7,12,7,400,9,7,1,7,1,7,5,7,404,8,7,10,7,12,7,407,9,7,1,7,1,7,5,7,411,
  	8,7,10,7,12,7,414,9,7,1,7,5,7,417,8,7,10,7,12,7,420,9,7,1,7,1,7,1,7,5,
  	7,425,8,7,10,7,12,7,428,9,7,1,7,1,7,5,7,432,8,7,10,7,12,7,435,9,7,1,7,
  	1,7,5,7,439,8,7,10,7,12,7,442,9,7,1,7,5,7,445,8,7,10,7,12,7,448,9,7,1,
  	7,1,7,1,7,5,7,453,8,7,10,7,12,7,456,9,7,1,7,1,7,5,7,460,8,7,10,7,12,7,
  	463,9,7,1,7,1,7,5,7,467,8,7,10,7,12,7,470,9,7,1,7,5,7,473,8,7,10,7,12,
  	7,476,9,7,1,7,1,7,1,7,5,7,481,8,7,10,7,12,7,484,9,7,1,7,1,7,5,7,488,8,
  	7,10,7,12,7,491,9,7,1,7,1,7,5,7,495,8,7,10,7,12,7,498,9,7,1,7,5,7,501,
  	8,7,10,7,12,7,504,9,7,1,7,1,7,1,7,5,7,509,8,7,10,7,12,7,512,9,7,1,7,1,
  	7,5,7,516,8,7,10,7,12,7,519,9,7,1,7,1,7,5,7,523,8,7,10,7,12,7,526,9,7,
  	1,7,5,7,529,8,7,10,7,12,7,532,9,7,1,7,1,7,1,7,5,7,537,8,7,10,7,12,7,540,
  	9,7,1,7,1,7,5,7,544,8,7,10,7,12,7,547,9,7,1,7,1,7,5,7,551,8,7,10,7,12,
  	7,554,9,7,1,7,1,7,5,7,558,8,7,10,7,12,7,561,9,7,1,7,1,7,5,7,565,8,7,10,
  	7,12,7,568,9,7,1,7,5,7,571,8,7,10,7,12,7,574,9,7,1,7,1,7,1,7,5,7,579,
  	8,7,10,7,12,7,582,9,7,1,7,1,7,5,7,586,8,7,10,7,12,7,589,9,7,1,7,1,7,5,
  	7,593,8,7,10,7,12,7,596,9,7,1,7,1,7,5,7,600,8,7,10,7,12,7,603,9,7,1,7,
  	1,7,5,7,607,8,7,10,7,12,7,610,9,7,1,7,1,7,5,7,614,8,7,10,7,12,7,617,9,
  	7,1,7,1,7,5,7,621,8,7,10,7,12,7,624,9,7,1,7,1,7,5,7,628,8,7,10,7,12,7,
  	631,9,7,1,7,1,7,5,7,635,8,7,10,7,12,7,638,9,7,1,7,5,7,641,8,7,10,7,12,
  	7,644,9,7,1,7,1,7,1,7,5,7,649,8,7,10,7,12,7,652,9,7,1,7,1,7,5,7,656,8,
  	7,10,7,12,7,659,9,7,1,7,1,7,5,7,663,8,7,10,7,12,7,666,9,7,1,7,5,7,669,
  	8,7,10,7,12,7,672,9,7,1,7,1,7,1,7,5,7,677,8,7,10,7,12,7,680,9,7,1,7,1,
  	7,5,7,684,8,7,10,7,12,7,687,9,7,1,7,1,7,5,7,691,8,7,10,7,12,7,694,9,7,
  	1,7,1,7,5,7,698,8,7,10,7,12,7,701,9,7,1,7,1,7,5,7,705,8,7,10,7,12,7,708,
  	9,7,1,7,5,7,711,8,7,10,7,12,7,714,9,7,1,7,1,7,1,7,5,7,719,8,7,10,7,12,
  	7,722,9,7,1,7,1,7,5,7,726,8,7,10,7,12,7,729,9,7,1,7,1,7,5,7,733,8,7,10,
  	7,12,7,736,9,7,1,7,1,7,5,7,740,8,7,10,7,12,7,743,9,7,1,7,1,7,5,7,747,
  	8,7,10,7,12,7,750,9,7,1,7,1,7,5,7,754,8,7,10,7,12,7,757,9,7,1,7,1,7,5,
  	7,761,8,7,10,7,12,7,764,9,7,1,7,1,7,5,7,768,8,7,10,7,12,7,771,9,7,1,7,
  	1,7,5,7,775,8,7,10,7,12,7,778,9,7,1,7,5,7,781,8,7,10,7,12,7,784,9,7,1,
  	7,1,7,1,7,5,7,789,8,7,10,7,12,7,792,9,7,1,7,1,7,5,7,796,8,7,10,7,12,7,
  	799,9,7,1,7,1,7,5,7,803,8,7,10,7,12,7,806,9,7,1,7,1,7,5,7,810,8,7,10,
  	7,12,7,813,9,7,1,7,1,7,5,7,817,8,7,10,7,12,7,820,9,7,1,7,5,7,823,8,7,
  	10,7,12,7,826,9,7,1,7,1,7,1,7,5,7,831,8,7,10,7,12,7,834,9,7,1,7,1,7,5,
  	7,838,8,7,10,7,12,7,841,9,7,1,7,1,7,5,7,845,8,7,10,7,12,7,848,9,7,1,7,
  	5,7,851,8,7,10,7,12,7,854,9,7,1,7,1,7,1,7,5,7,859,8,7,10,7,12,7,862,9,
  	7,1,7,1,7,5,7,866,8,7,10,7,12,7,869,9,7,1,7,1,7,5,7,873,8,7,10,7,12,7,
  	876,9,7,1,7,1,7,5,7,880,8,7,10,7,12,7,883,9,7,1,7,1,7,5,7,887,8,7,10,
  	7,12,7,890,9,7,1,7,1,7,5,7,894,8,7,10,7,12,7,897,9,7,1,7,1,7,5,7,901,
  	8,7,10,7,12,7,904,9,7,3,7,906,8,7,1,8,5,8,909,8,8,10,8,12,8,912,9,8,1,
  	8,1,8,1,8,1,8,1,8,1,8,1,8,5,8,921,8,8,10,8,12,8,924,9,8,1,8,1,8,1,8,5,
  	8,929,8,8,10,8,12,8,932,9,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,5,8,941,8,8,10,
  	8,12,8,944,9,8,1,8,1,8,1,8,5,8,949,8,8,10,8,12,8,952,9,8,1,8,1,8,1,8,
  	1,8,1,8,1,8,1,8,5,8,961,8,8,10,8,12,8,964,9,8,1,8,1,8,1,8,5,8,969,8,8,
  	10,8,12,8,972,9,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,5,8,981,8,8,10,8,12,8,984,
  	9,8,1,8,1,8,1,8,5,8,989,8,8,10,8,12,8,992,9,8,1,8,1,8,1,8,1,8,1,8,5,8,
  	999,8,8,10,8,12,8,1002,9,8,1,8,1,8,5,8,1006,8,8,10,8,12,8,1009,9,8,1,
  	8,5,8,1012,8,8,10,8,12,8,1015,9,8,1,8,1,8,1,8,1,8,1,8,5,8,1022,8,8,10,
  	8,12,8,1025,9,8,1,8,1,8,5,8,1029,8,8,10,8,12,8,1032,9,8,1,8,5,8,1035,
  	8,8,10,8,12,8,1038,9,8,1,8,1,8,1,8,1,8,1,8,5,8,1045,8,8,10,8,12,8,1048,
  	9,8,1,8,1,8,5,8,1052,8,8,10,8,12,8,1055,9,8,1,8,5,8,1058,8,8,10,8,12,
  	8,1061,9,8,1,8,1,8,1,8,1,8,1,8,5,8,1068,8,8,10,8,12,8,1071,9,8,1,8,1,
  	8,5,8,1075,8,8,10,8,12,8,1078,9,8,1,8,5,8,1081,8,8,10,8,12,8,1084,9,8,
  	1,8,1,8,1,8,1,8,1,8,5,8,1091,8,8,10,8,12,8,1094,9,8,1,8,1,8,5,8,1098,
  	8,8,10,8,12,8,1101,9,8,1,8,5,8,1104,8,8,10,8,12,8,1107,9,8,1,8,1,8,1,
  	8,1,8,1,8,5,8,1114,8,8,10,8,12,8,1117,9,8,1,8,1,8,5,8,1121,8,8,10,8,12,
  	8,1124,9,8,3,8,1126,8,8,1,9,5,9,1129,8,9,10,9,12,9,1132,9,9,1,9,1,9,1,
  	9,5,9,1137,8,9,10,9,12,9,1140,9,9,1,9,1,9,5,9,1144,8,9,10,9,12,9,1147,
  	9,9,1,9,1,9,5,9,1151,8,9,10,9,12,9,1154,9,9,1,9,5,9,1157,8,9,10,9,12,
  	9,1160,9,9,1,9,1,9,1,9,5,9,1165,8,9,10,9,12,9,1168,9,9,1,9,1,9,5,9,1172,
  	8,9,10,9,12,9,1175,9,9,1,9,1,9,5,9,1179,8,9,10,9,12,9,1182,9,9,1,9,1,
  	9,5,9,1186,8,9,10,9,12,9,1189,9,9,1,9,1,9,1,9,5,9,1194,8,9,10,9,12,9,
  	1197,9,9,4,9,1199,8,9,11,9,12,9,1200,1,9,5,9,1204,8,9,10,9,12,9,1207,
  	9,9,5,9,1209,8,9,10,9,12,9,1212,9,9,1,9,1,9,5,9,1216,8,9,10,9,12,9,1219,
  	9,9,3,9,1221,8,9,1,10,1,10,1,11,1,11,1,11,0,1,8,12,0,2,4,6,8,10,12,14,
  	16,18,20,22,0,4,1,0,53,54,1,0,55,56,2,0,48,48,61,61,2,0,22,22,24,24,1419,
  	0,46,1,0,0,0,2,48,1,0,0,0,4,153,1,0,0,0,6,158,1,0,0,0,8,231,1,0,0,0,10,
  	271,1,0,0,0,12,273,1,0,0,0,14,905,1,0,0,0,16,1125,1,0,0,0,18,1220,1,0,
  	0,0,20,1222,1,0,0,0,22,1224,1,0,0,0,24,26,5,46,0,0,25,24,1,0,0,0,26,29,
  	1,0,0,0,27,25,1,0,0,0,27,28,1,0,0,0,28,30,1,0,0,0,29,27,1,0,0,0,30,34,
  	5,10,0,0,31,33,5,46,0,0,32,31,1,0,0,0,33,36,1,0,0,0,34,32,1,0,0,0,34,
  	35,1,0,0,0,35,39,1,0,0,0,36,34,1,0,0,0,37,40,3,2,1,0,38,40,3,8,4,0,39,
  	37,1,0,0,0,39,38,1,0,0,0,40,42,1,0,0,0,41,43,5,47,0,0,42,41,1,0,0,0,42,
  	43,1,0,0,0,43,47,1,0,0,0,44,47,3,20,10,0,45,47,5,47,0,0,46,27,1,0,0,0,
  	46,44,1,0,0,0,46,45,1,0,0,0,47,1,1,0,0,0,48,52,5,2,0,0,49,51,5,46,0,0,
  	50,49,1,0,0,0,51,54,1,0,0,0,52,50,1,0,0,0,52,53,1,0,0,0,53,57,1,0,0,0,
  	54,52,1,0,0,0,55,58,3,8,4,0,56,58,3,2,1,0,57,55,1,0,0,0,57,56,1,0,0,0,
  	58,62,1,0,0,0,59,61,5,46,0,0,60,59,1,0,0,0,61,64,1,0,0,0,62,60,1,0,0,
  	0,62,63,1,0,0,0,63,78,1,0,0,0,64,62,1,0,0,0,65,69,5,52,0,0,66,68,5,46,
  	0,0,67,66,1,0,0,0,68,71,1,0,0,0,69,67,1,0,0,0,69,70,1,0,0,0,70,74,1,0,
  	0,0,71,69,1,0,0,0,72,75,3,8,4,0,73,75,3,2,1,0,74,72,1,0,0,0,74,73,1,0,
  	0,0,75,77,1,0,0,0,76,65,1,0,0,0,77,80,1,0,0,0,78,76,1,0,0,0,78,79,1,0,
  	0,0,79,81,1,0,0,0,80,78,1,0,0,0,81,82,5,3,0,0,82,3,1,0,0,0,83,85,5,46,
  	0,0,84,83,1,0,0,0,85,88,1,0,0,0,86,84,1,0,0,0,86,87,1,0,0,0,87,89,1,0,
  	0,0,88,86,1,0,0,0,89,93,5,49,0,0,90,92,5,46,0,0,91,90,1,0,0,0,92,95,1,
  	0,0,0,93,91,1,0,0,0,93,94,1,0,0,0,94,96,1,0,0,0,95,93,1,0,0,0,96,154,
  	5,50,0,0,97,101,5,49,0,0,98,100,5,46,0,0,99,98,1,0,0,0,100,103,1,0,0,
  	0,101,99,1,0,0,0,101,102,1,0,0,0,102,104,1,0,0,0,103,101,1,0,0,0,104,
  	108,5,48,0,0,105,107,5,46,0,0,106,105,1,0,0,0,107,110,1,0,0,0,108,106,
  	1,0,0,0,108,109,1,0,0,0,109,111,1,0,0,0,110,108,1,0,0,0,111,154,5,50,
  	0,0,112,116,5,49,0,0,113,115,5,46,0,0,114,113,1,0,0,0,115,118,1,0,0,0,
  	116,114,1,0,0,0,116,117,1,0,0,0,117,119,1,0,0,0,118,116,1,0,0,0,119,123,
  	5,48,0,0,120,122,5,46,0,0,121,120,1,0,0,0,122,125,1,0,0,0,123,121,1,0,
  	0,0,123,124,1,0,0,0,124,136,1,0,0,0,125,123,1,0,0,0,126,130,5,52,0,0,
  	127,129,5,46,0,0,128,127,1,0,0,0,129,132,1,0,0,0,130,128,1,0,0,0,130,
  	131,1,0,0,0,131,133,1,0,0,0,132,130,1,0,0,0,133,135,5,48,0,0,134,126,
  	1,0,0,0,135,138,1,0,0,0,136,134,1,0,0,0,136,137,1,0,0,0,137,142,1,0,0,
  	0,138,136,1,0,0,0,139,141,5,46,0,0,140,139,1,0,0,0,141,144,1,0,0,0,142,
  	140,1,0,0,0,142,143,1,0,0,0,143,145,1,0,0,0,144,142,1,0,0,0,145,146,5,
  	50,0,0,146,150,1,0,0,0,147,149,5,46,0,0,148,147,1,0,0,0,149,152,1,0,0,
  	0,150,148,1,0,0,0,150,151,1,0,0,0,151,154,1,0,0,0,152,150,1,0,0,0,153,
  	86,1,0,0,0,153,97,1,0,0,0,153,112,1,0,0,0,154,5,1,0,0,0,155,157,5,46,
  	0,0,156,155,1,0,0,0,157,160,1,0,0,0,158,156,1,0,0,0,158,159,1,0,0,0,159,
  	200,1,0,0,0,160,158,1,0,0,0,161,162,5,1,0,0,162,190,5,49,0,0,163,165,
  	5,46,0,0,164,163,1,0,0,0,165,168,1,0,0,0,166,164,1,0,0,0,166,167,1,0,
  	0,0,167,169,1,0,0,0,168,166,1,0,0,0,169,170,5,7,0,0,170,174,5,6,0,0,171,
  	173,5,46,0,0,172,171,1,0,0,0,173,176,1,0,0,0,174,172,1,0,0,0,174,175,
  	1,0,0,0,175,191,1,0,0,0,176,174,1,0,0,0,177,179,5,46,0,0,178,177,1,0,
  	0,0,179,182,1,0,0,0,180,178,1,0,0,0,180,181,1,0,0,0,181,183,1,0,0,0,182,
  	180,1,0,0,0,183,187,5,6,0,0,184,186,5,46,0,0,185,184,1,0,0,0,186,189,
  	1,0,0,0,187,185,1,0,0,0,187,188,1,0,0,0,188,191,1,0,0,0,189,187,1,0,0,
  	0,190,166,1,0,0,0,190,180,1,0,0,0,191,192,1,0,0,0,192,194,5,50,0,0,193,
  	195,3,4,2,0,194,193,1,0,0,0,194,195,1,0,0,0,195,201,1,0,0,0,196,198,5,
  	6,0,0,197,199,3,4,2,0,198,197,1,0,0,0,198,199,1,0,0,0,199,201,1,0,0,0,
  	200,161,1,0,0,0,200,196,1,0,0,0,201,205,1,0,0,0,202,204,5,46,0,0,203,
  	202,1,0,0,0,204,207,1,0,0,0,205,203,1,0,0,0,205,206,1,0,0,0,206,7,1,0,
  	0,0,207,205,1,0,0,0,208,209,6,4,-1,0,209,210,5,49,0,0,210,211,3,8,4,0,
  	211,212,5,50,0,0,212,232,1,0,0,0,213,232,3,6,3,0,214,218,3,14,7,0,215,
  	218,3,16,8,0,216,218,3,18,9,0,217,214,1,0,0,0,217,215,1,0,0,0,217,216,
  	1,0,0,0,218,232,1,0,0,0,219,222,3,10,5,0,220,222,3,12,6,0,221,219,1,0,
  	0,0,221,220,1,0,0,0,222,232,1,0,0,0,223,227,7,0,0,0,224,226,5,46,0,0,
  	225,224,1,0,0,0,226,229,1,0,0,0,227,225,1,0,0,0,227,228,1,0,0,0,228,230,
  	1,0,0,0,229,227,1,0,0,0,230,232,3,8,4,4,231,208,1,0,0,0,231,213,1,0,0,
  	0,231,217,1,0,0,0,231,221,1,0,0,0,231,223,1,0,0,0,232,268,1,0,0,0,233,
  	234,10,3,0,0,234,235,5,57,0,0,235,267,3,8,4,4,236,240,10,2,0,0,237,239,
  	5,46,0,0,238,237,1,0,0,0,239,242,1,0,0,0,240,238,1,0,0,0,240,241,1,0,
  	0,0,241,243,1,0,0,0,242,240,1,0,0,0,243,247,7,1,0,0,244,246,5,46,0,0,
  	245,244,1,0,0,0,246,249,1,0,0,0,247,245,1,0,0,0,247,248,1,0,0,0,248,250,
  	1,0,0,0,249,247,1,0,0,0,250,267,3,8,4,3,251,255,10,1,0,0,252,254,5,46,
  	0,0,253,252,1,0,0,0,254,257,1,0,0,0,255,253,1,0,0,0,255,256,1,0,0,0,256,
  	258,1,0,0,0,257,255,1,0,0,0,258,262,7,0,0,0,259,261,5,46,0,0,260,259,
  	1,0,0,0,261,264,1,0,0,0,262,260,1,0,0,0,262,263,1,0,0,0,263,265,1,0,0,
  	0,264,262,1,0,0,0,265,267,3,8,4,2,266,233,1,0,0,0,266,236,1,0,0,0,266,
  	251,1,0,0,0,267,270,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,9,1,0,
  	0,0,270,268,1,0,0,0,271,272,7,2,0,0,272,11,1,0,0,0,273,274,7,3,0,0,274,
  	13,1,0,0,0,275,277,5,46,0,0,276,275,1,0,0,0,277,280,1,0,0,0,278,276,1,
  	0,0,0,278,279,1,0,0,0,279,281,1,0,0,0,280,278,1,0,0,0,281,282,5,19,0,
  	0,282,286,5,49,0,0,283,285,5,46,0,0,284,283,1,0,0,0,285,288,1,0,0,0,286,
  	284,1,0,0,0,286,287,1,0,0,0,287,289,1,0,0,0,288,286,1,0,0,0,289,293,3,
  	8,4,0,290,292,5,46,0,0,291,290,1,0,0,0,292,295,1,0,0,0,293,291,1,0,0,
  	0,293,294,1,0,0,0,294,296,1,0,0,0,295,293,1,0,0,0,296,300,5,50,0,0,297,
  	299,5,46,0,0,298,297,1,0,0,0,299,302,1,0,0,0,300,298,1,0,0,0,300,301,
  	1,0,0,0,301,906,1,0,0,0,302,300,1,0,0,0,303,305,5,46,0,0,304,303,1,0,
  	0,0,305,308,1,0,0,0,306,304,1,0,0,0,306,307,1,0,0,0,307,309,1,0,0,0,308,
  	306,1,0,0,0,309,310,5,20,0,0,310,314,5,49,0,0,311,313,5,46,0,0,312,311,
  	1,0,0,0,313,316,1,0,0,0,314,312,1,0,0,0,314,315,1,0,0,0,315,317,1,0,0,
  	0,316,314,1,0,0,0,317,321,3,8,4,0,318,320,5,46,0,0,319,318,1,0,0,0,320,
  	323,1,0,0,0,321,319,1,0,0,0,321,322,1,0,0,0,322,324,1,0,0,0,323,321,1,
  	0,0,0,324,328,5,50,0,0,325,327,5,46,0,0,326,325,1,0,0,0,327,330,1,0,0,
  	0,328,326,1,0,0,0,328,329,1,0,0,0,329,906,1,0,0,0,330,328,1,0,0,0,331,
  	333,5,46,0,0,332,331,1,0,0,0,333,336,1,0,0,0,334,332,1,0,0,0,334,335,
  	1,0,0,0,335,337,1,0,0,0,336,334,1,0,0,0,337,338,5,22,0,0,338,342,5,49,
  	0,0,339,341,5,46,0,0,340,339,1,0,0,0,341,344,1,0,0,0,342,340,1,0,0,0,
  	342,343,1,0,0,0,343,345,1,0,0,0,344,342,1,0,0,0,345,349,3,8,4,0,346,348,
  	5,46,0,0,347,346,1,0,0,0,348,351,1,0,0,0,349,347,1,0,0,0,349,350,1,0,
  	0,0,350,352,1,0,0,0,351,349,1,0,0,0,352,356,5,50,0,0,353,355,5,46,0,0,
  	354,353,1,0,0,0,355,358,1,0,0,0,356,354,1,0,0,0,356,357,1,0,0,0,357,906,
  	1,0,0,0,358,356,1,0,0,0,359,361,5,46,0,0,360,359,1,0,0,0,361,364,1,0,
  	0,0,362,360,1,0,0,0,362,363,1,0,0,0,363,365,1,0,0,0,364,362,1,0,0,0,365,
  	366,5,23,0,0,366,370,5,49,0,0,367,369,5,46,0,0,368,367,1,0,0,0,369,372,
  	1,0,0,0,370,368,1,0,0,0,370,371,1,0,0,0,371,373,1,0,0,0,372,370,1,0,0,
  	0,373,377,3,8,4,0,374,376,5,46,0,0,375,374,1,0,0,0,376,379,1,0,0,0,377,
  	375,1,0,0,0,377,378,1,0,0,0,378,380,1,0,0,0,379,377,1,0,0,0,380,384,5,
  	50,0,0,381,383,5,46,0,0,382,381,1,0,0,0,383,386,1,0,0,0,384,382,1,0,0,
  	0,384,385,1,0,0,0,385,906,1,0,0,0,386,384,1,0,0,0,387,389,5,46,0,0,388,
  	387,1,0,0,0,389,392,1,0,0,0,390,388,1,0,0,0,390,391,1,0,0,0,391,393,1,
  	0,0,0,392,390,1,0,0,0,393,394,5,25,0,0,394,398,5,49,0,0,395,397,5,46,
  	0,0,396,395,1,0,0,0,397,400,1,0,0,0,398,396,1,0,0,0,398,399,1,0,0,0,399,
  	401,1,0,0,0,400,398,1,0,0,0,401,405,3,8,4,0,402,404,5,46,0,0,403,402,
  	1,0,0,0,404,407,1,0,0,0,405,403,1,0,0,0,405,406,1,0,0,0,406,408,1,0,0,
  	0,407,405,1,0,0,0,408,412,5,50,0,0,409,411,5,46,0,0,410,409,1,0,0,0,411,
  	414,1,0,0,0,412,410,1,0,0,0,412,413,1,0,0,0,413,906,1,0,0,0,414,412,1,
  	0,0,0,415,417,5,46,0,0,416,415,1,0,0,0,417,420,1,0,0,0,418,416,1,0,0,
  	0,418,419,1,0,0,0,419,421,1,0,0,0,420,418,1,0,0,0,421,422,5,26,0,0,422,
  	426,5,49,0,0,423,425,5,46,0,0,424,423,1,0,0,0,425,428,1,0,0,0,426,424,
  	1,0,0,0,426,427,1,0,0,0,427,429,1,0,0,0,428,426,1,0,0,0,429,433,3,8,4,
  	0,430,432,5,46,0,0,431,430,1,0,0,0,432,435,1,0,0,0,433,431,1,0,0,0,433,
  	434,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,440,5,50,0,0,437,439,
  	5,46,0,0,438,437,1,0,0,0,439,442,1,0,0,0,440,438,1,0,0,0,440,441,1,0,
  	0,0,441,906,1,0,0,0,442,440,1,0,0,0,443,445,5,46,0,0,444,443,1,0,0,0,
  	445,448,1,0,0,0,446,444,1,0,0,0,446,447,1,0,0,0,447,449,1,0,0,0,448,446,
  	1,0,0,0,449,450,5,28,0,0,450,454,5,49,0,0,451,453,5,46,0,0,452,451,1,
  	0,0,0,453,456,1,0,0,0,454,452,1,0,0,0,454,455,1,0,0,0,455,457,1,0,0,0,
  	456,454,1,0,0,0,457,461,3,8,4,0,458,460,5,46,0,0,459,458,1,0,0,0,460,
  	463,1,0,0,0,461,459,1,0,0,0,461,462,1,0,0,0,462,464,1,0,0,0,463,461,1,
  	0,0,0,464,468,5,50,0,0,465,467,5,46,0,0,466,465,1,0,0,0,467,470,1,0,0,
  	0,468,466,1,0,0,0,468,469,1,0,0,0,469,906,1,0,0,0,470,468,1,0,0,0,471,
  	473,5,46,0,0,472,471,1,0,0,0,473,476,1,0,0,0,474,472,1,0,0,0,474,475,
  	1,0,0,0,475,477,1,0,0,0,476,474,1,0,0,0,477,478,5,27,0,0,478,482,5,49,
  	0,0,479,481,5,46,0,0,480,479,1,0,0,0,481,484,1,0,0,0,482,480,1,0,0,0,
  	482,483,1,0,0,0,483,485,1,0,0,0,484,482,1,0,0,0,485,489,3,8,4,0,486,488,
  	5,46,0,0,487,486,1,0,0,0,488,491,1,0,0,0,489,487,1,0,0,0,489,490,1,0,
  	0,0,490,492,1,0,0,0,491,489,1,0,0,0,492,496,5,50,0,0,493,495,5,46,0,0,
  	494,493,1,0,0,0,495,498,1,0,0,0,496,494,1,0,0,0,496,497,1,0,0,0,497,906,
  	1,0,0,0,498,496,1,0,0,0,499,501,5,46,0,0,500,499,1,0,0,0,501,504,1,0,
  	0,0,502,500,1,0,0,0,502,503,1,0,0,0,503,505,1,0,0,0,504,502,1,0,0,0,505,
  	506,5,29,0,0,506,510,5,49,0,0,507,509,5,46,0,0,508,507,1,0,0,0,509,512,
  	1,0,0,0,510,508,1,0,0,0,510,511,1,0,0,0,511,513,1,0,0,0,512,510,1,0,0,
  	0,513,517,3,8,4,0,514,516,5,46,0,0,515,514,1,0,0,0,516,519,1,0,0,0,517,
  	515,1,0,0,0,517,518,1,0,0,0,518,520,1,0,0,0,519,517,1,0,0,0,520,524,5,
  	50,0,0,521,523,5,46,0,0,522,521,1,0,0,0,523,526,1,0,0,0,524,522,1,0,0,
  	0,524,525,1,0,0,0,525,906,1,0,0,0,526,524,1,0,0,0,527,529,5,46,0,0,528,
  	527,1,0,0,0,529,532,1,0,0,0,530,528,1,0,0,0,530,531,1,0,0,0,531,533,1,
  	0,0,0,532,530,1,0,0,0,533,534,5,21,0,0,534,538,5,49,0,0,535,537,5,46,
  	0,0,536,535,1,0,0,0,537,540,1,0,0,0,538,536,1,0,0,0,538,539,1,0,0,0,539,
  	541,1,0,0,0,540,538,1,0,0,0,541,545,3,8,4,0,542,544,5,46,0,0,543,542,
  	1,0,0,0,544,547,1,0,0,0,545,543,1,0,0,0,545,546,1,0,0,0,546,548,1,0,0,
  	0,547,545,1,0,0,0,548,552,5,52,0,0,549,551,5,46,0,0,550,549,1,0,0,0,551,
  	554,1,0,0,0,552,550,1,0,0,0,552,553,1,0,0,0,553,555,1,0,0,0,554,552,1,
  	0,0,0,555,559,3,8,4,0,556,558,5,46,0,0,557,556,1,0,0,0,558,561,1,0,0,
  	0,559,557,1,0,0,0,559,560,1,0,0,0,560,562,1,0,0,0,561,559,1,0,0,0,562,
  	566,5,50,0,0,563,565,5,46,0,0,564,563,1,0,0,0,565,568,1,0,0,0,566,564,
  	1,0,0,0,566,567,1,0,0,0,567,906,1,0,0,0,568,566,1,0,0,0,569,571,5,46,
  	0,0,570,569,1,0,0,0,571,574,1,0,0,0,572,570,1,0,0,0,572,573,1,0,0,0,573,
  	575,1,0,0,0,574,572,1,0,0,0,575,576,5,33,0,0,576,580,5,49,0,0,577,579,
  	5,46,0,0,578,577,1,0,0,0,579,582,1,0,0,0,580,578,1,0,0,0,580,581,1,0,
  	0,0,581,583,1,0,0,0,582,580,1,0,0,0,583,587,3,8,4,0,584,586,5,46,0,0,
  	585,584,1,0,0,0,586,589,1,0,0,0,587,585,1,0,0,0,587,588,1,0,0,0,588,590,
  	1,0,0,0,589,587,1,0,0,0,590,594,5,52,0,0,591,593,5,46,0,0,592,591,1,0,
  	0,0,593,596,1,0,0,0,594,592,1,0,0,0,594,595,1,0,0,0,595,597,1,0,0,0,596,
  	594,1,0,0,0,597,601,3,8,4,0,598,600,5,46,0,0,599,598,1,0,0,0,600,603,
  	1,0,0,0,601,599,1,0,0,0,601,602,1,0,0,0,602,604,1,0,0,0,603,601,1,0,0,
  	0,604,608,5,52,0,0,605,607,5,46,0,0,606,605,1,0,0,0,607,610,1,0,0,0,608,
  	606,1,0,0,0,608,609,1,0,0,0,609,611,1,0,0,0,610,608,1,0,0,0,611,615,3,
  	8,4,0,612,614,5,46,0,0,613,612,1,0,0,0,614,617,1,0,0,0,615,613,1,0,0,
  	0,615,616,1,0,0,0,616,618,1,0,0,0,617,615,1,0,0,0,618,622,5,52,0,0,619,
  	621,5,46,0,0,620,619,1,0,0,0,621,624,1,0,0,0,622,620,1,0,0,0,622,623,
  	1,0,0,0,623,625,1,0,0,0,624,622,1,0,0,0,625,629,3,8,4,0,626,628,5,46,
  	0,0,627,626,1,0,0,0,628,631,1,0,0,0,629,627,1,0,0,0,629,630,1,0,0,0,630,
  	632,1,0,0,0,631,629,1,0,0,0,632,636,5,50,0,0,633,635,5,46,0,0,634,633,
  	1,0,0,0,635,638,1,0,0,0,636,634,1,0,0,0,636,637,1,0,0,0,637,906,1,0,0,
  	0,638,636,1,0,0,0,639,641,5,46,0,0,640,639,1,0,0,0,641,644,1,0,0,0,642,
  	640,1,0,0,0,642,643,1,0,0,0,643,645,1,0,0,0,644,642,1,0,0,0,645,646,5,
  	34,0,0,646,650,5,49,0,0,647,649,5,46,0,0,648,647,1,0,0,0,649,652,1,0,
  	0,0,650,648,1,0,0,0,650,651,1,0,0,0,651,653,1,0,0,0,652,650,1,0,0,0,653,
  	657,3,8,4,0,654,656,5,46,0,0,655,654,1,0,0,0,656,659,1,0,0,0,657,655,
  	1,0,0,0,657,658,1,0,0,0,658,660,1,0,0,0,659,657,1,0,0,0,660,664,5,50,
  	0,0,661,663,5,46,0,0,662,661,1,0,0,0,663,666,1,0,0,0,664,662,1,0,0,0,
  	664,665,1,0,0,0,665,906,1,0,0,0,666,664,1,0,0,0,667,669,5,46,0,0,668,
  	667,1,0,0,0,669,672,1,0,0,0,670,668,1,0,0,0,670,671,1,0,0,0,671,673,1,
  	0,0,0,672,670,1,0,0,0,673,674,5,35,0,0,674,678,5,49,0,0,675,677,5,46,
  	0,0,676,675,1,0,0,0,677,680,1,0,0,0,678,676,1,0,0,0,678,679,1,0,0,0,679,
  	681,1,0,0,0,680,678,1,0,0,0,681,685,3,8,4,0,682,684,5,46,0,0,683,682,
  	1,0,0,0,684,687,1,0,0,0,685,683,1,0,0,0,685,686,1,0,0,0,686,688,1,0,0,
  	0,687,685,1,0,0,0,688,692,5,52,0,0,689,691,5,46,0,0,690,689,1,0,0,0,691,
  	694,1,0,0,0,692,690,1,0,0,0,692,693,1,0,0,0,693,695,1,0,0,0,694,692,1,
  	0,0,0,695,699,3,8,4,0,696,698,5,46,0,0,697,696,1,0,0,0,698,701,1,0,0,
  	0,699,697,1,0,0,0,699,700,1,0,0,0,700,702,1,0,0,0,701,699,1,0,0,0,702,
  	706,5,50,0,0,703,705,5,46,0,0,704,703,1,0,0,0,705,708,1,0,0,0,706,704,
  	1,0,0,0,706,707,1,0,0,0,707,906,1,0,0,0,708,706,1,0,0,0,709,711,5,46,
  	0,0,710,709,1,0,0,0,711,714,1,0,0,0,712,710,1,0,0,0,712,713,1,0,0,0,713,
  	715,1,0,0,0,714,712,1,0,0,0,715,716,5,36,0,0,716,720,5,49,0,0,717,719,
  	5,46,0,0,718,717,1,0,0,0,719,722,1,0,0,0,720,718,1,0,0,0,720,721,1,0,
  	0,0,721,723,1,0,0,0,722,720,1,0,0,0,723,727,3,8,4,0,724,726,5,46,0,0,
  	725,724,1,0,0,0,726,729,1,0,0,0,727,725,1,0,0,0,727,728,1,0,0,0,728,730,
  	1,0,0,0,729,727,1,0,0,0,730,734,5,52,0,0,731,733,5,46,0,0,732,731,1,0,
  	0,0,733,736,1,0,0,0,734,732,1,0,0,0,734,735,1,0,0,0,735,737,1,0,0,0,736,
  	734,1,0,0,0,737,741,3,8,4,0,738,740,5,46,0,0,739,738,1,0,0,0,740,743,
  	1,0,0,0,741,739,1,0,0,0,741,742,1,0,0,0,742,744,1,0,0,0,743,741,1,0,0,
  	0,744,748,5,52,0,0,745,747,5,46,0,0,746,745,1,0,0,0,747,750,1,0,0,0,748,
  	746,1,0,0,0,748,749,1,0,0,0,749,751,1,0,0,0,750,748,1,0,0,0,751,755,3,
  	8,4,0,752,754,5,46,0,0,753,752,1,0,0,0,754,757,1,0,0,0,755,753,1,0,0,
  	0,755,756,1,0,0,0,756,758,1,0,0,0,757,755,1,0,0,0,758,762,5,52,0,0,759,
  	761,5,46,0,0,760,759,1,0,0,0,761,764,1,0,0,0,762,760,1,0,0,0,762,763,
  	1,0,0,0,763,765,1,0,0,0,764,762,1,0,0,0,765,769,3,8,4,0,766,768,5,46,
  	0,0,767,766,1,0,0,0,768,771,1,0,0,0,769,767,1,0,0,0,769,770,1,0,0,0,770,
  	772,1,0,0,0,771,769,1,0,0,0,772,776,5,50,0,0,773,775,5,46,0,0,774,773,
  	1,0,0,0,775,778,1,0,0,0,776,774,1,0,0,0,776,777,1,0,0,0,777,906,1,0,0,
  	0,778,776,1,0,0,0,779,781,5,46,0,0,780,779,1,0,0,0,781,784,1,0,0,0,782,
  	780,1,0,0,0,782,783,1,0,0,0,783,785,1,0,0,0,784,782,1,0,0,0,785,786,5,
  	43,0,0,786,790,5,49,0,0,787,789,5,46,0,0,788,787,1,0,0,0,789,792,1,0,
  	0,0,790,788,1,0,0,0,790,791,1,0,0,0,791,793,1,0,0,0,792,790,1,0,0,0,793,
  	797,3,8,4,0,794,796,5,46,0,0,795,794,1,0,0,0,796,799,1,0,0,0,797,795,
  	1,0,0,0,797,798,1,0,0,0,798,800,1,0,0,0,799,797,1,0,0,0,800,804,5,52,
  	0,0,801,803,5,46,0,0,802,801,1,0,0,0,803,806,1,0,0,0,804,802,1,0,0,0,
  	804,805,1,0,0,0,805,807,1,0,0,0,806,804,1,0,0,0,807,811,3,8,4,0,808,810,
  	5,46,0,0,809,808,1,0,0,0,810,813,1,0,0,0,811,809,1,0,0,0,811,812,1,0,
  	0,0,812,814,1,0,0,0,813,811,1,0,0,0,814,818,5,50,0,0,815,817,5,46,0,0,
  	816,815,1,0,0,0,817,820,1,0,0,0,818,816,1,0,0,0,818,819,1,0,0,0,819,906,
  	1,0,0,0,820,818,1,0,0,0,821,823,5,46,0,0,822,821,1,0,0,0,823,826,1,0,
  	0,0,824,822,1,0,0,0,824,825,1,0,0,0,825,827,1,0,0,0,826,824,1,0,0,0,827,
  	828,5,37,0,0,828,832,5,49,0,0,829,831,5,46,0,0,830,829,1,0,0,0,831,834,
  	1,0,0,0,832,830,1,0,0,0,832,833,1,0,0,0,833,835,1,0,0,0,834,832,1,0,0,
  	0,835,839,3,8,4,0,836,838,5,46,0,0,837,836,1,0,0,0,838,841,1,0,0,0,839,
  	837,1,0,0,0,839,840,1,0,0,0,840,842,1,0,0,0,841,839,1,0,0,0,842,846,5,
  	50,0,0,843,845,5,46,0,0,844,843,1,0,0,0,845,848,1,0,0,0,846,844,1,0,0,
  	0,846,847,1,0,0,0,847,906,1,0,0,0,848,846,1,0,0,0,849,851,5,46,0,0,850,
  	849,1,0,0,0,851,854,1,0,0,0,852,850,1,0,0,0,852,853,1,0,0,0,853,855,1,
  	0,0,0,854,852,1,0,0,0,855,856,5,38,0,0,856,860,5,49,0,0,857,859,5,46,
  	0,0,858,857,1,0,0,0,859,862,1,0,0,0,860,858,1,0,0,0,860,861,1,0,0,0,861,
  	863,1,0,0,0,862,860,1,0,0,0,863,867,3,8,4,0,864,866,5,46,0,0,865,864,
  	1,0,0,0,866,869,1,0,0,0,867,865,1,0,0,0,867,868,1,0,0,0,868,870,1,0,0,
  	0,869,867,1,0,0,0,870,874,5,52,0,0,871,873,5,46,0,0,872,871,1,0,0,0,873,
  	876,1,0,0,0,874,872,1,0,0,0,874,875,1,0,0,0,875,877,1,0,0,0,876,874,1,
  	0,0,0,877,881,3,8,4,0,878,880,5,46,0,0,879,878,1,0,0,0,880,883,1,0,0,
  	0,881,879,1,0,0,0,881,882,1,0,0,0,882,884,1,0,0,0,883,881,1,0,0,0,884,
  	888,5,52,0,0,885,887,5,46,0,0,886,885,1,0,0,0,887,890,1,0,0,0,888,886,
  	1,0,0,0,888,889,1,0,0,0,889,891,1,0,0,0,890,888,1,0,0,0,891,895,3,8,4,
  	0,892,894,5,46,0,0,893,892,1,0,0,0,894,897,1,0,0,0,895,893,1,0,0,0,895,
  	896,1,0,0,0,896,898,1,0,0,0,897,895,1,0,0,0,898,902,5,50,0,0,899,901,
  	5,46,0,0,900,899,1,0,0,0,901,904,1,0,0,0,902,900,1,0,0,0,902,903,1,0,
  	0,0,903,906,1,0,0,0,904,902,1,0,0,0,905,278,1,0,0,0,905,306,1,0,0,0,905,
  	334,1,0,0,0,905,362,1,0,0,0,905,390,1,0,0,0,905,418,1,0,0,0,905,446,1,
  	0,0,0,905,474,1,0,0,0,905,502,1,0,0,0,905,530,1,0,0,0,905,572,1,0,0,0,
  	905,642,1,0,0,0,905,670,1,0,0,0,905,712,1,0,0,0,905,782,1,0,0,0,905,824,
  	1,0,0,0,905,852,1,0,0,0,906,15,1,0,0,0,907,909,5,46,0,0,908,907,1,0,0,
  	0,909,912,1,0,0,0,910,908,1,0,0,0,910,911,1,0,0,0,911,913,1,0,0,0,912,
  	910,1,0,0,0,913,914,5,13,0,0,914,915,5,49,0,0,915,916,3,8,4,0,916,917,
  	5,52,0,0,917,922,3,8,4,0,918,919,5,52,0,0,919,921,3,8,4,0,920,918,1,0,
  	0,0,921,924,1,0,0,0,922,920,1,0,0,0,922,923,1,0,0,0,923,925,1,0,0,0,924,
  	922,1,0,0,0,925,926,5,50,0,0,926,1126,1,0,0,0,927,929,5,46,0,0,928,927,
  	1,0,0,0,929,932,1,0,0,0,930,928,1,0,0,0,930,931,1,0,0,0,931,933,1,0,0,
  	0,932,930,1,0,0,0,933,934,5,15,0,0,934,935,5,49,0,0,935,936,3,8,4,0,936,
  	937,5,52,0,0,937,942,3,8,4,0,938,939,5,52,0,0,939,941,3,8,4,0,940,938,
  	1,0,0,0,941,944,1,0,0,0,942,940,1,0,0,0,942,943,1,0,0,0,943,945,1,0,0,
  	0,944,942,1,0,0,0,945,946,5,50,0,0,946,1126,1,0,0,0,947,949,5,46,0,0,
  	948,947,1,0,0,0,949,952,1,0,0,0,950,948,1,0,0,0,950,951,1,0,0,0,951,953,
  	1,0,0,0,952,950,1,0,0,0,953,954,5,17,0,0,954,955,5,49,0,0,955,956,3,8,
  	4,0,956,957,5,52,0,0,957,962,3,8,4,0,958,959,5,52,0,0,959,961,3,8,4,0,
  	960,958,1,0,0,0,961,964,1,0,0,0,962,960,1,0,0,0,962,963,1,0,0,0,963,965,
  	1,0,0,0,964,962,1,0,0,0,965,966,5,50,0,0,966,1126,1,0,0,0,967,969,5,46,
  	0,0,968,967,1,0,0,0,969,972,1,0,0,0,970,968,1,0,0,0,970,971,1,0,0,0,971,
  	973,1,0,0,0,972,970,1,0,0,0,973,974,5,32,0,0,974,975,5,49,0,0,975,976,
  	3,22,11,0,976,977,5,52,0,0,977,982,3,22,11,0,978,979,5,52,0,0,979,981,
  	3,22,11,0,980,978,1,0,0,0,981,984,1,0,0,0,982,980,1,0,0,0,982,983,1,0,
  	0,0,983,985,1,0,0,0,984,982,1,0,0,0,985,986,5,50,0,0,986,1126,1,0,0,0,
  	987,989,5,46,0,0,988,987,1,0,0,0,989,992,1,0,0,0,990,988,1,0,0,0,990,
  	991,1,0,0,0,991,993,1,0,0,0,992,990,1,0,0,0,993,994,5,30,0,0,994,995,
  	5,49,0,0,995,1000,3,22,11,0,996,997,5,52,0,0,997,999,3,22,11,0,998,996,
  	1,0,0,0,999,1002,1,0,0,0,1000,998,1,0,0,0,1000,1001,1,0,0,0,1001,1003,
  	1,0,0,0,1002,1000,1,0,0,0,1003,1007,5,50,0,0,1004,1006,5,46,0,0,1005,
  	1004,1,0,0,0,1006,1009,1,0,0,0,1007,1005,1,0,0,0,1007,1008,1,0,0,0,1008,
  	1126,1,0,0,0,1009,1007,1,0,0,0,1010,1012,5,46,0,0,1011,1010,1,0,0,0,1012,
  	1015,1,0,0,0,1013,1011,1,0,0,0,1013,1014,1,0,0,0,1014,1016,1,0,0,0,1015,
  	1013,1,0,0,0,1016,1017,5,31,0,0,1017,1018,5,49,0,0,1018,1023,3,22,11,
  	0,1019,1020,5,52,0,0,1020,1022,3,22,11,0,1021,1019,1,0,0,0,1022,1025,
  	1,0,0,0,1023,1021,1,0,0,0,1023,1024,1,0,0,0,1024,1026,1,0,0,0,1025,1023,
  	1,0,0,0,1026,1030,5,50,0,0,1027,1029,5,46,0,0,1028,1027,1,0,0,0,1029,
  	1032,1,0,0,0,1030,1028,1,0,0,0,1030,1031,1,0,0,0,1031,1126,1,0,0,0,1032,
  	1030,1,0,0,0,1033,1035,5,46,0,0,1034,1033,1,0,0,0,1035,1038,1,0,0,0,1036,
  	1034,1,0,0,0,1036,1037,1,0,0,0,1037,1039,1,0,0,0,1038,1036,1,0,0,0,1039,
  	1040,5,39,0,0,1040,1041,5,49,0,0,1041,1046,3,8,4,0,1042,1043,5,52,0,0,
  	1043,1045,3,8,4,0,1044,1042,1,0,0,0,1045,1048,1,0,0,0,1046,1044,1,0,0,
  	0,1046,1047,1,0,0,0,1047,1049,1,0,0,0,1048,1046,1,0,0,0,1049,1053,5,50,
  	0,0,1050,1052,5,46,0,0,1051,1050,1,0,0,0,1052,1055,1,0,0,0,1053,1051,
  	1,0,0,0,1053,1054,1,0,0,0,1054,1126,1,0,0,0,1055,1053,1,0,0,0,1056,1058,
  	5,46,0,0,1057,1056,1,0,0,0,1058,1061,1,0,0,0,1059,1057,1,0,0,0,1059,1060,
  	1,0,0,0,1060,1062,1,0,0,0,1061,1059,1,0,0,0,1062,1063,5,40,0,0,1063,1064,
  	5,49,0,0,1064,1069,3,8,4,0,1065,1066,5,52,0,0,1066,1068,3,8,4,0,1067,
  	1065,1,0,0,0,1068,1071,1,0,0,0,1069,1067,1,0,0,0,1069,1070,1,0,0,0,1070,
  	1072,1,0,0,0,1071,1069,1,0,0,0,1072,1076,5,50,0,0,1073,1075,5,46,0,0,
  	1074,1073,1,0,0,0,1075,1078,1,0,0,0,1076,1074,1,0,0,0,1076,1077,1,0,0,
  	0,1077,1126,1,0,0,0,1078,1076,1,0,0,0,1079,1081,5,46,0,0,1080,1079,1,
  	0,0,0,1081,1084,1,0,0,0,1082,1080,1,0,0,0,1082,1083,1,0,0,0,1083,1085,
  	1,0,0,0,1084,1082,1,0,0,0,1085,1086,5,41,0,0,1086,1087,5,49,0,0,1087,
  	1092,3,8,4,0,1088,1089,5,52,0,0,1089,1091,3,8,4,0,1090,1088,1,0,0,0,1091,
  	1094,1,0,0,0,1092,1090,1,0,0,0,1092,1093,1,0,0,0,1093,1095,1,0,0,0,1094,
  	1092,1,0,0,0,1095,1099,5,50,0,0,1096,1098,5,46,0,0,1097,1096,1,0,0,0,
  	1098,1101,1,0,0,0,1099,1097,1,0,0,0,1099,1100,1,0,0,0,1100,1126,1,0,0,
  	0,1101,1099,1,0,0,0,1102,1104,5,46,0,0,1103,1102,1,0,0,0,1104,1107,1,
  	0,0,0,1105,1103,1,0,0,0,1105,1106,1,0,0,0,1106,1108,1,0,0,0,1107,1105,
  	1,0,0,0,1108,1109,5,42,0,0,1109,1110,5,49,0,0,1110,1115,3,8,4,0,1111,
  	1112,5,52,0,0,1112,1114,3,8,4,0,1113,1111,1,0,0,0,1114,1117,1,0,0,0,1115,
  	1113,1,0,0,0,1115,1116,1,0,0,0,1116,1118,1,0,0,0,1117,1115,1,0,0,0,1118,
  	1122,5,50,0,0,1119,1121,5,46,0,0,1120,1119,1,0,0,0,1121,1124,1,0,0,0,
  	1122,1120,1,0,0,0,1122,1123,1,0,0,0,1123,1126,1,0,0,0,1124,1122,1,0,0,
  	0,1125,910,1,0,0,0,1125,930,1,0,0,0,1125,950,1,0,0,0,1125,970,1,0,0,0,
  	1125,990,1,0,0,0,1125,1013,1,0,0,0,1125,1036,1,0,0,0,1125,1059,1,0,0,
  	0,1125,1082,1,0,0,0,1125,1105,1,0,0,0,1126,17,1,0,0,0,1127,1129,5,46,
  	0,0,1128,1127,1,0,0,0,1129,1132,1,0,0,0,1130,1128,1,0,0,0,1130,1131,1,
  	0,0,0,1131,1133,1,0,0,0,1132,1130,1,0,0,0,1133,1134,5,16,0,0,1134,1138,
  	5,49,0,0,1135,1137,5,46,0,0,1136,1135,1,0,0,0,1137,1140,1,0,0,0,1138,
  	1136,1,0,0,0,1138,1139,1,0,0,0,1139,1141,1,0,0,0,1140,1138,1,0,0,0,1141,
  	1145,3,8,4,0,1142,1144,5,46,0,0,1143,1142,1,0,0,0,1144,1147,1,0,0,0,1145,
  	1143,1,0,0,0,1145,1146,1,0,0,0,1146,1148,1,0,0,0,1147,1145,1,0,0,0,1148,
  	1152,5,50,0,0,1149,1151,5,46,0,0,1150,1149,1,0,0,0,1151,1154,1,0,0,0,
  	1152,1150,1,0,0,0,1152,1153,1,0,0,0,1153,1221,1,0,0,0,1154,1152,1,0,0,
  	0,1155,1157,5,46,0,0,1156,1155,1,0,0,0,1157,1160,1,0,0,0,1158,1156,1,
  	0,0,0,1158,1159,1,0,0,0,1159,1161,1,0,0,0,1160,1158,1,0,0,0,1161,1162,
  	5,18,0,0,1162,1166,5,49,0,0,1163,1165,5,46,0,0,1164,1163,1,0,0,0,1165,
  	1168,1,0,0,0,1166,1164,1,0,0,0,1166,1167,1,0,0,0,1167,1169,1,0,0,0,1168,
  	1166,1,0,0,0,1169,1173,3,8,4,0,1170,1172,5,46,0,0,1171,1170,1,0,0,0,1172,
  	1175,1,0,0,0,1173,1171,1,0,0,0,1173,1174,1,0,0,0,1174,1210,1,0,0,0,1175,
  	1173,1,0,0,0,1176,1180,5,52,0,0,1177,1179,5,46,0,0,1178,1177,1,0,0,0,
  	1179,1182,1,0,0,0,1180,1178,1,0,0,0,1180,1181,1,0,0,0,1181,1183,1,0,0,
  	0,1182,1180,1,0,0,0,1183,1198,3,6,3,0,1184,1186,5,46,0,0,1185,1184,1,
  	0,0,0,1186,1189,1,0,0,0,1187,1185,1,0,0,0,1187,1188,1,0,0,0,1188,1190,
  	1,0,0,0,1189,1187,1,0,0,0,1190,1191,5,52,0,0,1191,1195,5,48,0,0,1192,
  	1194,5,46,0,0,1193,1192,1,0,0,0,1194,1197,1,0,0,0,1195,1193,1,0,0,0,1195,
  	1196,1,0,0,0,1196,1199,1,0,0,0,1197,1195,1,0,0,0,1198,1187,1,0,0,0,1199,
  	1200,1,0,0,0,1200,1198,1,0,0,0,1200,1201,1,0,0,0,1201,1205,1,0,0,0,1202,
  	1204,5,46,0,0,1203,1202,1,0,0,0,1204,1207,1,0,0,0,1205,1203,1,0,0,0,1205,
  	1206,1,0,0,0,1206,1209,1,0,0,0,1207,1205,1,0,0,0,1208,1176,1,0,0,0,1209,
  	1212,1,0,0,0,1210,1208,1,0,0,0,1210,1211,1,0,0,0,1211,1213,1,0,0,0,1212,
  	1210,1,0,0,0,1213,1217,5,50,0,0,1214,1216,5,46,0,0,1215,1214,1,0,0,0,
  	1216,1219,1,0,0,0,1217,1215,1,0,0,0,1217,1218,1,0,0,0,1218,1221,1,0,0,
  	0,1219,1217,1,0,0,0,1220,1130,1,0,0,0,1220,1158,1,0,0,0,1221,19,1,0,0,
  	0,1222,1223,5,45,0,0,1223,21,1,0,0,0,1224,1225,5,44,0,0,1225,23,1,0,0,
  	0,175,27,34,39,42,46,52,57,62,69,74,78,86,93,101,108,116,123,130,136,
  	142,150,153,158,166,174,180,187,190,194,198,200,205,217,221,227,231,240,
  	247,255,262,266,268,278,286,293,300,306,314,321,328,334,342,349,356,362,
  	370,377,384,390,398,405,412,418,426,433,440,446,454,461,468,474,482,489,
  	496,502,510,517,524,530,538,545,552,559,566,572,580,587,594,601,608,615,
  	622,629,636,642,650,657,664,670,678,685,692,699,706,712,720,727,734,741,
  	748,755,762,769,776,782,790,797,804,811,818,824,832,839,846,852,860,867,
  	874,881,888,895,902,905,910,922,930,942,950,962,970,982,990,1000,1007,
  	1013,1023,1030,1036,1046,1053,1059,1069,1076,1082,1092,1099,1105,1115,
  	1122,1125,1130,1138,1145,1152,1158,1166,1173,1180,1187,1195,1200,1205,
  	1210,1217,1220
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  detect_type_functionParserStaticData = staticData.release();
}

}

detect_type_function::detect_type_function(TokenStream *input) : detect_type_function(input, antlr4::atn::ParserATNSimulatorOptions()) {}

detect_type_function::detect_type_function(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  detect_type_function::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *detect_type_functionParserStaticData->atn, detect_type_functionParserStaticData->decisionToDFA, detect_type_functionParserStaticData->sharedContextCache, options);
}

detect_type_function::~detect_type_function() {
  delete _interpreter;
}

const atn::ATN& detect_type_function::getATN() const {
  return *detect_type_functionParserStaticData->atn;
}

std::string detect_type_function::getGrammarFileName() const {
  return "detect_type_function.g4";
}

const std::vector<std::string>& detect_type_function::getRuleNames() const {
  return detect_type_functionParserStaticData->ruleNames;
}

const dfa::Vocabulary& detect_type_function::getVocabulary() const {
  return detect_type_functionParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView detect_type_function::getSerializedATN() const {
  return detect_type_functionParserStaticData->serializedATN;
}


//----------------- Line_inputContext ------------------------------------------------------------------

detect_type_function::Line_inputContext::Line_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::Line_inputContext::EQUAL() {
  return getToken(detect_type_function::EQUAL, 0);
}

detect_type_function::ArrayContext* detect_type_function::Line_inputContext::array() {
  return getRuleContext<detect_type_function::ArrayContext>(0);
}

detect_type_function::ExprContext* detect_type_function::Line_inputContext::expr() {
  return getRuleContext<detect_type_function::ExprContext>(0);
}

std::vector<tree::TerminalNode *> detect_type_function::Line_inputContext::WS() {
  return getTokens(detect_type_function::WS);
}

tree::TerminalNode* detect_type_function::Line_inputContext::WS(size_t i) {
  return getToken(detect_type_function::WS, i);
}

tree::TerminalNode* detect_type_function::Line_inputContext::EOL() {
  return getToken(detect_type_function::EOL, 0);
}

detect_type_function::StringContext* detect_type_function::Line_inputContext::string() {
  return getRuleContext<detect_type_function::StringContext>(0);
}


size_t detect_type_function::Line_inputContext::getRuleIndex() const {
  return detect_type_function::RuleLine_input;
}

void detect_type_function::Line_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLine_input(this);
}

void detect_type_function::Line_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLine_input(this);
}

detect_type_function::Line_inputContext* detect_type_function::line_input() {
  Line_inputContext *_localctx = _tracker.createInstance<Line_inputContext>(_ctx, getState());
  enterRule(_localctx, 0, detect_type_function::RuleLine_input);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(46);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case detect_type_function::EQUAL:
      case detect_type_function::WS: {
        enterOuterAlt(_localctx, 1);
        setState(27);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == detect_type_function::WS) {
          setState(24);
          match(detect_type_function::WS);
          setState(29);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(30);
        match(detect_type_function::EQUAL);
        setState(34);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(31);
            match(detect_type_function::WS); 
          }
          setState(36);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
        }
        setState(39);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case detect_type_function::BEG_ARR: {
            setState(37);
            array();
            break;
          }

          case detect_type_function::VAR_TAG:
          case detect_type_function::VARIABLE:
          case detect_type_function::SUMPRODUCT:
          case detect_type_function::SUM:
          case detect_type_function::SUM_I:
          case detect_type_function::PRODUCT:
          case detect_type_function::PRODUCT_I:
          case detect_type_function::LN:
          case detect_type_function::LG:
          case detect_type_function::LOG_X:
          case detect_type_function::EXP:
          case detect_type_function::SQRT:
          case detect_type_function::PI:
          case detect_type_function::COS:
          case detect_type_function::SIN:
          case detect_type_function::ASIN:
          case detect_type_function::ACOS:
          case detect_type_function::FACTORIAL:
          case detect_type_function::SEARCH_STRING:
          case detect_type_function::CONTAIN_TEXT:
          case detect_type_function::CONCAT:
          case detect_type_function::WEIBULL_DISTRIB:
          case detect_type_function::GAUSS:
          case detect_type_function::STD_NORM_DISTRIB:
          case detect_type_function::NORM_DISTRIB:
          case detect_type_function::GAMMA:
          case detect_type_function::GAMMA_REV:
          case detect_type_function::ROOT_MEAN_SQUARE:
          case detect_type_function::ROOT_MEAN_SQUARE_ERROR:
          case detect_type_function::AVERAGE:
          case detect_type_function::MEDIAN:
          case detect_type_function::PEARSON:
          case detect_type_function::WS:
          case detect_type_function::UINT:
          case detect_type_function::Lb:
          case detect_type_function::ADD:
          case detect_type_function::SUB:
          case detect_type_function::FLOAT: {
            setState(38);
            expr(0);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(42);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == detect_type_function::EOL) {
          setState(41);
          match(detect_type_function::EOL);
        }
        break;
      }

      case detect_type_function::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(44);
        string();
        break;
      }

      case detect_type_function::EOL: {
        enterOuterAlt(_localctx, 3);
        setState(45);
        match(detect_type_function::EOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayContext ------------------------------------------------------------------

detect_type_function::ArrayContext::ArrayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::ArrayContext::BEG_ARR() {
  return getToken(detect_type_function::BEG_ARR, 0);
}

tree::TerminalNode* detect_type_function::ArrayContext::END_ARR() {
  return getToken(detect_type_function::END_ARR, 0);
}

std::vector<detect_type_function::ExprContext *> detect_type_function::ArrayContext::expr() {
  return getRuleContexts<detect_type_function::ExprContext>();
}

detect_type_function::ExprContext* detect_type_function::ArrayContext::expr(size_t i) {
  return getRuleContext<detect_type_function::ExprContext>(i);
}

std::vector<detect_type_function::ArrayContext *> detect_type_function::ArrayContext::array() {
  return getRuleContexts<detect_type_function::ArrayContext>();
}

detect_type_function::ArrayContext* detect_type_function::ArrayContext::array(size_t i) {
  return getRuleContext<detect_type_function::ArrayContext>(i);
}

std::vector<tree::TerminalNode *> detect_type_function::ArrayContext::WS() {
  return getTokens(detect_type_function::WS);
}

tree::TerminalNode* detect_type_function::ArrayContext::WS(size_t i) {
  return getToken(detect_type_function::WS, i);
}

std::vector<tree::TerminalNode *> detect_type_function::ArrayContext::SEPAR() {
  return getTokens(detect_type_function::SEPAR);
}

tree::TerminalNode* detect_type_function::ArrayContext::SEPAR(size_t i) {
  return getToken(detect_type_function::SEPAR, i);
}


size_t detect_type_function::ArrayContext::getRuleIndex() const {
  return detect_type_function::RuleArray;
}

void detect_type_function::ArrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray(this);
}

void detect_type_function::ArrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray(this);
}

detect_type_function::ArrayContext* detect_type_function::array() {
  ArrayContext *_localctx = _tracker.createInstance<ArrayContext>(_ctx, getState());
  enterRule(_localctx, 2, detect_type_function::RuleArray);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(48);
    match(detect_type_function::BEG_ARR);
    setState(52);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(49);
        match(detect_type_function::WS); 
      }
      setState(54);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
    }
    setState(57);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case detect_type_function::VAR_TAG:
      case detect_type_function::VARIABLE:
      case detect_type_function::SUMPRODUCT:
      case detect_type_function::SUM:
      case detect_type_function::SUM_I:
      case detect_type_function::PRODUCT:
      case detect_type_function::PRODUCT_I:
      case detect_type_function::LN:
      case detect_type_function::LG:
      case detect_type_function::LOG_X:
      case detect_type_function::EXP:
      case detect_type_function::SQRT:
      case detect_type_function::PI:
      case detect_type_function::COS:
      case detect_type_function::SIN:
      case detect_type_function::ASIN:
      case detect_type_function::ACOS:
      case detect_type_function::FACTORIAL:
      case detect_type_function::SEARCH_STRING:
      case detect_type_function::CONTAIN_TEXT:
      case detect_type_function::CONCAT:
      case detect_type_function::WEIBULL_DISTRIB:
      case detect_type_function::GAUSS:
      case detect_type_function::STD_NORM_DISTRIB:
      case detect_type_function::NORM_DISTRIB:
      case detect_type_function::GAMMA:
      case detect_type_function::GAMMA_REV:
      case detect_type_function::ROOT_MEAN_SQUARE:
      case detect_type_function::ROOT_MEAN_SQUARE_ERROR:
      case detect_type_function::AVERAGE:
      case detect_type_function::MEDIAN:
      case detect_type_function::PEARSON:
      case detect_type_function::WS:
      case detect_type_function::UINT:
      case detect_type_function::Lb:
      case detect_type_function::ADD:
      case detect_type_function::SUB:
      case detect_type_function::FLOAT: {
        setState(55);
        expr(0);
        break;
      }

      case detect_type_function::BEG_ARR: {
        setState(56);
        array();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(62);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == detect_type_function::WS) {
      setState(59);
      match(detect_type_function::WS);
      setState(64);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(78);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == detect_type_function::SEPAR) {
      setState(65);
      match(detect_type_function::SEPAR);
      setState(69);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(66);
          match(detect_type_function::WS); 
        }
        setState(71);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
      }
      setState(74);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case detect_type_function::VAR_TAG:
        case detect_type_function::VARIABLE:
        case detect_type_function::SUMPRODUCT:
        case detect_type_function::SUM:
        case detect_type_function::SUM_I:
        case detect_type_function::PRODUCT:
        case detect_type_function::PRODUCT_I:
        case detect_type_function::LN:
        case detect_type_function::LG:
        case detect_type_function::LOG_X:
        case detect_type_function::EXP:
        case detect_type_function::SQRT:
        case detect_type_function::PI:
        case detect_type_function::COS:
        case detect_type_function::SIN:
        case detect_type_function::ASIN:
        case detect_type_function::ACOS:
        case detect_type_function::FACTORIAL:
        case detect_type_function::SEARCH_STRING:
        case detect_type_function::CONTAIN_TEXT:
        case detect_type_function::CONCAT:
        case detect_type_function::WEIBULL_DISTRIB:
        case detect_type_function::GAUSS:
        case detect_type_function::STD_NORM_DISTRIB:
        case detect_type_function::NORM_DISTRIB:
        case detect_type_function::GAMMA:
        case detect_type_function::GAMMA_REV:
        case detect_type_function::ROOT_MEAN_SQUARE:
        case detect_type_function::ROOT_MEAN_SQUARE_ERROR:
        case detect_type_function::AVERAGE:
        case detect_type_function::MEDIAN:
        case detect_type_function::PEARSON:
        case detect_type_function::WS:
        case detect_type_function::UINT:
        case detect_type_function::Lb:
        case detect_type_function::ADD:
        case detect_type_function::SUB:
        case detect_type_function::FLOAT: {
          setState(72);
          expr(0);
          break;
        }

        case detect_type_function::BEG_ARR: {
          setState(73);
          array();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(80);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(81);
    match(detect_type_function::END_ARR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Node_accessContext ------------------------------------------------------------------

detect_type_function::Node_accessContext::Node_accessContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::Node_accessContext::Lb() {
  return getToken(detect_type_function::Lb, 0);
}

tree::TerminalNode* detect_type_function::Node_accessContext::Rb() {
  return getToken(detect_type_function::Rb, 0);
}

std::vector<tree::TerminalNode *> detect_type_function::Node_accessContext::WS() {
  return getTokens(detect_type_function::WS);
}

tree::TerminalNode* detect_type_function::Node_accessContext::WS(size_t i) {
  return getToken(detect_type_function::WS, i);
}

std::vector<tree::TerminalNode *> detect_type_function::Node_accessContext::UINT() {
  return getTokens(detect_type_function::UINT);
}

tree::TerminalNode* detect_type_function::Node_accessContext::UINT(size_t i) {
  return getToken(detect_type_function::UINT, i);
}

std::vector<tree::TerminalNode *> detect_type_function::Node_accessContext::SEPAR() {
  return getTokens(detect_type_function::SEPAR);
}

tree::TerminalNode* detect_type_function::Node_accessContext::SEPAR(size_t i) {
  return getToken(detect_type_function::SEPAR, i);
}


size_t detect_type_function::Node_accessContext::getRuleIndex() const {
  return detect_type_function::RuleNode_access;
}

void detect_type_function::Node_accessContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode_access(this);
}

void detect_type_function::Node_accessContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode_access(this);
}

detect_type_function::Node_accessContext* detect_type_function::node_access() {
  Node_accessContext *_localctx = _tracker.createInstance<Node_accessContext>(_ctx, getState());
  enterRule(_localctx, 4, detect_type_function::RuleNode_access);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(153);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(86);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(83);
        match(detect_type_function::WS);
        setState(88);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }

      setState(89);
      match(detect_type_function::Lb);
      setState(93);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(90);
        match(detect_type_function::WS);
        setState(95);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(96);
      match(detect_type_function::Rb);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(97);
      match(detect_type_function::Lb);
      setState(101);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(98);
        match(detect_type_function::WS);
        setState(103);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(104);
      match(detect_type_function::UINT);
      setState(108);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(105);
        match(detect_type_function::WS);
        setState(110);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(111);
      match(detect_type_function::Rb);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(112);
      match(detect_type_function::Lb);
      setState(116);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(113);
        match(detect_type_function::WS);
        setState(118);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(119);
      match(detect_type_function::UINT);
      setState(123);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(120);
          match(detect_type_function::WS); 
        }
        setState(125);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
      }
      setState(136);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(126);
        match(detect_type_function::SEPAR);
        setState(130);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == detect_type_function::WS) {
          setState(127);
          match(detect_type_function::WS);
          setState(132);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(133);
        match(detect_type_function::UINT);
        setState(138);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(142);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(139);
        match(detect_type_function::WS);
        setState(144);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(145);
      match(detect_type_function::Rb);
      setState(150);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(147);
          match(detect_type_function::WS); 
        }
        setState(152);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableContext ------------------------------------------------------------------

detect_type_function::VariableContext::VariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> detect_type_function::VariableContext::WS() {
  return getTokens(detect_type_function::WS);
}

tree::TerminalNode* detect_type_function::VariableContext::WS(size_t i) {
  return getToken(detect_type_function::WS, i);
}

tree::TerminalNode* detect_type_function::VariableContext::VAR_TAG() {
  return getToken(detect_type_function::VAR_TAG, 0);
}

tree::TerminalNode* detect_type_function::VariableContext::Lb() {
  return getToken(detect_type_function::Lb, 0);
}

tree::TerminalNode* detect_type_function::VariableContext::Rb() {
  return getToken(detect_type_function::Rb, 0);
}

tree::TerminalNode* detect_type_function::VariableContext::VARIABLE() {
  return getToken(detect_type_function::VARIABLE, 0);
}

tree::TerminalNode* detect_type_function::VariableContext::DATABASE() {
  return getToken(detect_type_function::DATABASE, 0);
}

detect_type_function::Node_accessContext* detect_type_function::VariableContext::node_access() {
  return getRuleContext<detect_type_function::Node_accessContext>(0);
}


size_t detect_type_function::VariableContext::getRuleIndex() const {
  return detect_type_function::RuleVariable;
}

void detect_type_function::VariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable(this);
}

void detect_type_function::VariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable(this);
}

detect_type_function::VariableContext* detect_type_function::variable() {
  VariableContext *_localctx = _tracker.createInstance<VariableContext>(_ctx, getState());
  enterRule(_localctx, 6, detect_type_function::RuleVariable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(158);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == detect_type_function::WS) {
      setState(155);
      match(detect_type_function::WS);
      setState(160);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(200);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case detect_type_function::VAR_TAG: {
        setState(161);
        match(detect_type_function::VAR_TAG);
        setState(162);
        match(detect_type_function::Lb);
        setState(190);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
        case 1: {
          setState(166);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == detect_type_function::WS) {
            setState(163);
            match(detect_type_function::WS);
            setState(168);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(169);
          match(detect_type_function::DATABASE);
          setState(170);
          match(detect_type_function::VARIABLE);
          setState(174);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == detect_type_function::WS) {
            setState(171);
            match(detect_type_function::WS);
            setState(176);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          break;
        }

        case 2: {
          setState(180);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == detect_type_function::WS) {
            setState(177);
            match(detect_type_function::WS);
            setState(182);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(183);
          match(detect_type_function::VARIABLE);
          setState(187);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == detect_type_function::WS) {
            setState(184);
            match(detect_type_function::WS);
            setState(189);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          break;
        }

        default:
          break;
        }
        setState(192);
        match(detect_type_function::Rb);
        setState(194);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
        case 1: {
          setState(193);
          node_access();
          break;
        }

        default:
          break;
        }
        break;
      }

      case detect_type_function::VARIABLE: {
        setState(196);
        match(detect_type_function::VARIABLE);
        setState(198);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
        case 1: {
          setState(197);
          node_access();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(205);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(202);
        match(detect_type_function::WS); 
      }
      setState(207);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

detect_type_function::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t detect_type_function::ExprContext::getRuleIndex() const {
  return detect_type_function::RuleExpr;
}

void detect_type_function::ExprContext::copyFrom(ExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- UnaryOpContext ------------------------------------------------------------------

detect_type_function::ExprContext* detect_type_function::UnaryOpContext::expr() {
  return getRuleContext<detect_type_function::ExprContext>(0);
}

tree::TerminalNode* detect_type_function::UnaryOpContext::ADD() {
  return getToken(detect_type_function::ADD, 0);
}

tree::TerminalNode* detect_type_function::UnaryOpContext::SUB() {
  return getToken(detect_type_function::SUB, 0);
}

std::vector<tree::TerminalNode *> detect_type_function::UnaryOpContext::WS() {
  return getTokens(detect_type_function::WS);
}

tree::TerminalNode* detect_type_function::UnaryOpContext::WS(size_t i) {
  return getToken(detect_type_function::WS, i);
}

detect_type_function::UnaryOpContext::UnaryOpContext(ExprContext *ctx) { copyFrom(ctx); }

void detect_type_function::UnaryOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryOp(this);
}
void detect_type_function::UnaryOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryOp(this);
}
//----------------- ParensContext ------------------------------------------------------------------

tree::TerminalNode* detect_type_function::ParensContext::Lb() {
  return getToken(detect_type_function::Lb, 0);
}

detect_type_function::ExprContext* detect_type_function::ParensContext::expr() {
  return getRuleContext<detect_type_function::ExprContext>(0);
}

tree::TerminalNode* detect_type_function::ParensContext::Rb() {
  return getToken(detect_type_function::Rb, 0);
}

detect_type_function::ParensContext::ParensContext(ExprContext *ctx) { copyFrom(ctx); }

void detect_type_function::ParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParens(this);
}
void detect_type_function::ParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParens(this);
}
//----------------- LiteralContext ------------------------------------------------------------------

detect_type_function::NumberContext* detect_type_function::LiteralContext::number() {
  return getRuleContext<detect_type_function::NumberContext>(0);
}

detect_type_function::ConstantContext* detect_type_function::LiteralContext::constant() {
  return getRuleContext<detect_type_function::ConstantContext>(0);
}

detect_type_function::LiteralContext::LiteralContext(ExprContext *ctx) { copyFrom(ctx); }

void detect_type_function::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}
void detect_type_function::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}
//----------------- FunctionCallContext ------------------------------------------------------------------

detect_type_function::FunctionContext* detect_type_function::FunctionCallContext::function() {
  return getRuleContext<detect_type_function::FunctionContext>(0);
}

detect_type_function::MultiargfunctionContext* detect_type_function::FunctionCallContext::multiargfunction() {
  return getRuleContext<detect_type_function::MultiargfunctionContext>(0);
}

detect_type_function::RangefunctionContext* detect_type_function::FunctionCallContext::rangefunction() {
  return getRuleContext<detect_type_function::RangefunctionContext>(0);
}

detect_type_function::FunctionCallContext::FunctionCallContext(ExprContext *ctx) { copyFrom(ctx); }

void detect_type_function::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}
void detect_type_function::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}
//----------------- VariableInExprContext ------------------------------------------------------------------

detect_type_function::VariableContext* detect_type_function::VariableInExprContext::variable() {
  return getRuleContext<detect_type_function::VariableContext>(0);
}

detect_type_function::VariableInExprContext::VariableInExprContext(ExprContext *ctx) { copyFrom(ctx); }

void detect_type_function::VariableInExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableInExpr(this);
}
void detect_type_function::VariableInExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableInExpr(this);
}
//----------------- BinaryOpContext ------------------------------------------------------------------

std::vector<detect_type_function::ExprContext *> detect_type_function::BinaryOpContext::expr() {
  return getRuleContexts<detect_type_function::ExprContext>();
}

detect_type_function::ExprContext* detect_type_function::BinaryOpContext::expr(size_t i) {
  return getRuleContext<detect_type_function::ExprContext>(i);
}

tree::TerminalNode* detect_type_function::BinaryOpContext::POW() {
  return getToken(detect_type_function::POW, 0);
}

tree::TerminalNode* detect_type_function::BinaryOpContext::MUL() {
  return getToken(detect_type_function::MUL, 0);
}

tree::TerminalNode* detect_type_function::BinaryOpContext::DIV() {
  return getToken(detect_type_function::DIV, 0);
}

std::vector<tree::TerminalNode *> detect_type_function::BinaryOpContext::WS() {
  return getTokens(detect_type_function::WS);
}

tree::TerminalNode* detect_type_function::BinaryOpContext::WS(size_t i) {
  return getToken(detect_type_function::WS, i);
}

tree::TerminalNode* detect_type_function::BinaryOpContext::ADD() {
  return getToken(detect_type_function::ADD, 0);
}

tree::TerminalNode* detect_type_function::BinaryOpContext::SUB() {
  return getToken(detect_type_function::SUB, 0);
}

detect_type_function::BinaryOpContext::BinaryOpContext(ExprContext *ctx) { copyFrom(ctx); }

void detect_type_function::BinaryOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryOp(this);
}
void detect_type_function::BinaryOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryOp(this);
}

detect_type_function::ExprContext* detect_type_function::expr() {
   return expr(0);
}

detect_type_function::ExprContext* detect_type_function::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  detect_type_function::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  detect_type_function::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 8;
  enterRecursionRule(_localctx, 8, detect_type_function::RuleExpr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(231);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ParensContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(209);
      match(detect_type_function::Lb);
      setState(210);
      expr(0);
      setState(211);
      match(detect_type_function::Rb);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<VariableInExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(213);
      variable();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<FunctionCallContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(217);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
      case 1: {
        setState(214);
        function();
        break;
      }

      case 2: {
        setState(215);
        multiargfunction();
        break;
      }

      case 3: {
        setState(216);
        rangefunction();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LiteralContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(221);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case detect_type_function::UINT:
        case detect_type_function::FLOAT: {
          setState(219);
          number();
          break;
        }

        case detect_type_function::EXP:
        case detect_type_function::PI: {
          setState(220);
          constant();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<UnaryOpContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(223);
      _la = _input->LA(1);
      if (!(_la == detect_type_function::ADD

      || _la == detect_type_function::SUB)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(227);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(224);
          match(detect_type_function::WS); 
        }
        setState(229);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
      }
      setState(230);
      expr(4);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(268);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(266);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<BinaryOpContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(233);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(234);
          match(detect_type_function::POW);
          setState(235);
          expr(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<BinaryOpContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(236);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(240);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == detect_type_function::WS) {
            setState(237);
            match(detect_type_function::WS);
            setState(242);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(243);
          _la = _input->LA(1);
          if (!(_la == detect_type_function::MUL

          || _la == detect_type_function::DIV)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(247);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(244);
              match(detect_type_function::WS); 
            }
            setState(249);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx);
          }
          setState(250);
          expr(3);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<BinaryOpContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(251);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(255);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == detect_type_function::WS) {
            setState(252);
            match(detect_type_function::WS);
            setState(257);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(258);
          _la = _input->LA(1);
          if (!(_la == detect_type_function::ADD

          || _la == detect_type_function::SUB)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(262);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(259);
              match(detect_type_function::WS); 
            }
            setState(264);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
          }
          setState(265);
          expr(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(270);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

detect_type_function::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::NumberContext::UINT() {
  return getToken(detect_type_function::UINT, 0);
}

tree::TerminalNode* detect_type_function::NumberContext::FLOAT() {
  return getToken(detect_type_function::FLOAT, 0);
}


size_t detect_type_function::NumberContext::getRuleIndex() const {
  return detect_type_function::RuleNumber;
}

void detect_type_function::NumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumber(this);
}

void detect_type_function::NumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumber(this);
}

detect_type_function::NumberContext* detect_type_function::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 10, detect_type_function::RuleNumber);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(271);
    _la = _input->LA(1);
    if (!(_la == detect_type_function::UINT

    || _la == detect_type_function::FLOAT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

detect_type_function::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::ConstantContext::PI() {
  return getToken(detect_type_function::PI, 0);
}

tree::TerminalNode* detect_type_function::ConstantContext::EXP() {
  return getToken(detect_type_function::EXP, 0);
}


size_t detect_type_function::ConstantContext::getRuleIndex() const {
  return detect_type_function::RuleConstant;
}

void detect_type_function::ConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant(this);
}

void detect_type_function::ConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant(this);
}

detect_type_function::ConstantContext* detect_type_function::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 12, detect_type_function::RuleConstant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(273);
    _la = _input->LA(1);
    if (!(_la == detect_type_function::EXP

    || _la == detect_type_function::PI)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionContext ------------------------------------------------------------------

detect_type_function::FunctionContext::FunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::FunctionContext::LN() {
  return getToken(detect_type_function::LN, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::Lb() {
  return getToken(detect_type_function::Lb, 0);
}

std::vector<detect_type_function::ExprContext *> detect_type_function::FunctionContext::expr() {
  return getRuleContexts<detect_type_function::ExprContext>();
}

detect_type_function::ExprContext* detect_type_function::FunctionContext::expr(size_t i) {
  return getRuleContext<detect_type_function::ExprContext>(i);
}

tree::TerminalNode* detect_type_function::FunctionContext::Rb() {
  return getToken(detect_type_function::Rb, 0);
}

std::vector<tree::TerminalNode *> detect_type_function::FunctionContext::WS() {
  return getTokens(detect_type_function::WS);
}

tree::TerminalNode* detect_type_function::FunctionContext::WS(size_t i) {
  return getToken(detect_type_function::WS, i);
}

tree::TerminalNode* detect_type_function::FunctionContext::LG() {
  return getToken(detect_type_function::LG, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::EXP() {
  return getToken(detect_type_function::EXP, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::SQRT() {
  return getToken(detect_type_function::SQRT, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::COS() {
  return getToken(detect_type_function::COS, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::SIN() {
  return getToken(detect_type_function::SIN, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::ACOS() {
  return getToken(detect_type_function::ACOS, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::ASIN() {
  return getToken(detect_type_function::ASIN, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::FACTORIAL() {
  return getToken(detect_type_function::FACTORIAL, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::LOG_X() {
  return getToken(detect_type_function::LOG_X, 0);
}

std::vector<tree::TerminalNode *> detect_type_function::FunctionContext::SEPAR() {
  return getTokens(detect_type_function::SEPAR);
}

tree::TerminalNode* detect_type_function::FunctionContext::SEPAR(size_t i) {
  return getToken(detect_type_function::SEPAR, i);
}

tree::TerminalNode* detect_type_function::FunctionContext::WEIBULL_DISTRIB() {
  return getToken(detect_type_function::WEIBULL_DISTRIB, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::GAUSS() {
  return getToken(detect_type_function::GAUSS, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::STD_NORM_DISTRIB() {
  return getToken(detect_type_function::STD_NORM_DISTRIB, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::NORM_DISTRIB() {
  return getToken(detect_type_function::NORM_DISTRIB, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::PEARSON() {
  return getToken(detect_type_function::PEARSON, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::GAMMA() {
  return getToken(detect_type_function::GAMMA, 0);
}

tree::TerminalNode* detect_type_function::FunctionContext::GAMMA_REV() {
  return getToken(detect_type_function::GAMMA_REV, 0);
}


size_t detect_type_function::FunctionContext::getRuleIndex() const {
  return detect_type_function::RuleFunction;
}

void detect_type_function::FunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction(this);
}

void detect_type_function::FunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction(this);
}

detect_type_function::FunctionContext* detect_type_function::function() {
  FunctionContext *_localctx = _tracker.createInstance<FunctionContext>(_ctx, getState());
  enterRule(_localctx, 14, detect_type_function::RuleFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(905);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(278);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(275);
        match(detect_type_function::WS);
        setState(280);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(281);
      match(detect_type_function::LN);
      setState(282);
      match(detect_type_function::Lb);
      setState(286);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(283);
          match(detect_type_function::WS); 
        }
        setState(288);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx);
      }
      setState(289);
      expr(0);
      setState(293);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(290);
        match(detect_type_function::WS);
        setState(295);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(296);
      match(detect_type_function::Rb);
      setState(300);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(297);
          match(detect_type_function::WS); 
        }
        setState(302);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(306);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(303);
        match(detect_type_function::WS);
        setState(308);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(309);
      match(detect_type_function::LG);
      setState(310);
      match(detect_type_function::Lb);
      setState(314);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(311);
          match(detect_type_function::WS); 
        }
        setState(316);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
      }
      setState(317);
      expr(0);
      setState(321);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(318);
        match(detect_type_function::WS);
        setState(323);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(324);
      match(detect_type_function::Rb);
      setState(328);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(325);
          match(detect_type_function::WS); 
        }
        setState(330);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(334);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(331);
        match(detect_type_function::WS);
        setState(336);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(337);
      match(detect_type_function::EXP);
      setState(338);
      match(detect_type_function::Lb);
      setState(342);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(339);
          match(detect_type_function::WS); 
        }
        setState(344);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx);
      }
      setState(345);
      expr(0);
      setState(349);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(346);
        match(detect_type_function::WS);
        setState(351);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(352);
      match(detect_type_function::Rb);
      setState(356);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(353);
          match(detect_type_function::WS); 
        }
        setState(358);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(362);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(359);
        match(detect_type_function::WS);
        setState(364);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(365);
      match(detect_type_function::SQRT);
      setState(366);
      match(detect_type_function::Lb);
      setState(370);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(367);
          match(detect_type_function::WS); 
        }
        setState(372);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx);
      }
      setState(373);
      expr(0);
      setState(377);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(374);
        match(detect_type_function::WS);
        setState(379);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(380);
      match(detect_type_function::Rb);
      setState(384);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(381);
          match(detect_type_function::WS); 
        }
        setState(386);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(390);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(387);
        match(detect_type_function::WS);
        setState(392);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(393);
      match(detect_type_function::COS);
      setState(394);
      match(detect_type_function::Lb);
      setState(398);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(395);
          match(detect_type_function::WS); 
        }
        setState(400);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
      }
      setState(401);
      expr(0);
      setState(405);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(402);
        match(detect_type_function::WS);
        setState(407);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(408);
      match(detect_type_function::Rb);
      setState(412);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(409);
          match(detect_type_function::WS); 
        }
        setState(414);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(418);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(415);
        match(detect_type_function::WS);
        setState(420);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(421);
      match(detect_type_function::SIN);
      setState(422);
      match(detect_type_function::Lb);
      setState(426);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(423);
          match(detect_type_function::WS); 
        }
        setState(428);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx);
      }
      setState(429);
      expr(0);
      setState(433);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(430);
        match(detect_type_function::WS);
        setState(435);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(436);
      match(detect_type_function::Rb);
      setState(440);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(437);
          match(detect_type_function::WS); 
        }
        setState(442);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx);
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(446);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(443);
        match(detect_type_function::WS);
        setState(448);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(449);
      match(detect_type_function::ACOS);
      setState(450);
      match(detect_type_function::Lb);
      setState(454);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(451);
          match(detect_type_function::WS); 
        }
        setState(456);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
      }
      setState(457);
      expr(0);
      setState(461);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(458);
        match(detect_type_function::WS);
        setState(463);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(464);
      match(detect_type_function::Rb);
      setState(468);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(465);
          match(detect_type_function::WS); 
        }
        setState(470);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx);
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(474);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(471);
        match(detect_type_function::WS);
        setState(476);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(477);
      match(detect_type_function::ASIN);
      setState(478);
      match(detect_type_function::Lb);
      setState(482);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(479);
          match(detect_type_function::WS); 
        }
        setState(484);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
      }
      setState(485);
      expr(0);
      setState(489);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(486);
        match(detect_type_function::WS);
        setState(491);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(492);
      match(detect_type_function::Rb);
      setState(496);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(493);
          match(detect_type_function::WS); 
        }
        setState(498);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(502);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(499);
        match(detect_type_function::WS);
        setState(504);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(505);
      match(detect_type_function::FACTORIAL);
      setState(506);
      match(detect_type_function::Lb);
      setState(510);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(507);
          match(detect_type_function::WS); 
        }
        setState(512);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
      }
      setState(513);
      expr(0);
      setState(517);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(514);
        match(detect_type_function::WS);
        setState(519);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(520);
      match(detect_type_function::Rb);
      setState(524);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(521);
          match(detect_type_function::WS); 
        }
        setState(526);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(530);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(527);
        match(detect_type_function::WS);
        setState(532);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(533);
      match(detect_type_function::LOG_X);
      setState(534);
      match(detect_type_function::Lb);
      setState(538);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(535);
          match(detect_type_function::WS); 
        }
        setState(540);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx);
      }
      setState(541);
      expr(0);
      setState(545);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(542);
        match(detect_type_function::WS);
        setState(547);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(548);
      match(detect_type_function::SEPAR);
      setState(552);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(549);
          match(detect_type_function::WS); 
        }
        setState(554);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx);
      }
      setState(555);
      expr(0);
      setState(559);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(556);
        match(detect_type_function::WS);
        setState(561);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(562);
      match(detect_type_function::Rb);
      setState(566);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(563);
          match(detect_type_function::WS); 
        }
        setState(568);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(572);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(569);
        match(detect_type_function::WS);
        setState(574);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(575);
      match(detect_type_function::WEIBULL_DISTRIB);
      setState(576);
      match(detect_type_function::Lb);
      setState(580);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(577);
          match(detect_type_function::WS); 
        }
        setState(582);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx);
      }
      setState(583);
      expr(0);
      setState(587);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(584);
        match(detect_type_function::WS);
        setState(589);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(590);
      match(detect_type_function::SEPAR);
      setState(594);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(591);
          match(detect_type_function::WS); 
        }
        setState(596);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
      }
      setState(597);
      expr(0);
      setState(601);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(598);
        match(detect_type_function::WS);
        setState(603);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(604);
      match(detect_type_function::SEPAR);
      setState(608);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(605);
          match(detect_type_function::WS); 
        }
        setState(610);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
      }
      setState(611);
      expr(0);
      setState(615);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(612);
        match(detect_type_function::WS);
        setState(617);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(618);
      match(detect_type_function::SEPAR);
      setState(622);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(619);
          match(detect_type_function::WS); 
        }
        setState(624);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
      }
      setState(625);
      expr(0);
      setState(629);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(626);
        match(detect_type_function::WS);
        setState(631);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(632);
      match(detect_type_function::Rb);
      setState(636);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(633);
          match(detect_type_function::WS); 
        }
        setState(638);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(642);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(639);
        match(detect_type_function::WS);
        setState(644);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(645);
      match(detect_type_function::GAUSS);
      setState(646);
      match(detect_type_function::Lb);
      setState(650);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(647);
          match(detect_type_function::WS); 
        }
        setState(652);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
      }
      setState(653);
      expr(0);
      setState(657);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(654);
        match(detect_type_function::WS);
        setState(659);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(660);
      match(detect_type_function::Rb);
      setState(664);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(661);
          match(detect_type_function::WS); 
        }
        setState(666);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(670);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(667);
        match(detect_type_function::WS);
        setState(672);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(673);
      match(detect_type_function::STD_NORM_DISTRIB);
      setState(674);
      match(detect_type_function::Lb);
      setState(678);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(675);
          match(detect_type_function::WS); 
        }
        setState(680);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
      }
      setState(681);
      expr(0);
      setState(685);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(682);
        match(detect_type_function::WS);
        setState(687);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(688);
      match(detect_type_function::SEPAR);
      setState(692);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(689);
          match(detect_type_function::WS); 
        }
        setState(694);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
      }
      setState(695);
      expr(0);
      setState(699);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(696);
        match(detect_type_function::WS);
        setState(701);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(702);
      match(detect_type_function::Rb);
      setState(706);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(703);
          match(detect_type_function::WS); 
        }
        setState(708);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
      }
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(712);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(709);
        match(detect_type_function::WS);
        setState(714);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(715);
      match(detect_type_function::NORM_DISTRIB);
      setState(716);
      match(detect_type_function::Lb);
      setState(720);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(717);
          match(detect_type_function::WS); 
        }
        setState(722);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx);
      }
      setState(723);
      expr(0);
      setState(727);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(724);
        match(detect_type_function::WS);
        setState(729);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(730);
      match(detect_type_function::SEPAR);
      setState(734);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(731);
          match(detect_type_function::WS); 
        }
        setState(736);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
      }
      setState(737);
      expr(0);
      setState(741);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(738);
        match(detect_type_function::WS);
        setState(743);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(744);
      match(detect_type_function::SEPAR);
      setState(748);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(745);
          match(detect_type_function::WS); 
        }
        setState(750);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
      }
      setState(751);
      expr(0);
      setState(755);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(752);
        match(detect_type_function::WS);
        setState(757);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(758);
      match(detect_type_function::SEPAR);
      setState(762);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(759);
          match(detect_type_function::WS); 
        }
        setState(764);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
      }
      setState(765);
      expr(0);
      setState(769);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(766);
        match(detect_type_function::WS);
        setState(771);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(772);
      match(detect_type_function::Rb);
      setState(776);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(773);
          match(detect_type_function::WS); 
        }
        setState(778);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx);
      }
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(782);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(779);
        match(detect_type_function::WS);
        setState(784);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(785);
      match(detect_type_function::PEARSON);
      setState(786);
      match(detect_type_function::Lb);
      setState(790);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(787);
          match(detect_type_function::WS); 
        }
        setState(792);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx);
      }
      setState(793);
      expr(0);
      setState(797);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(794);
        match(detect_type_function::WS);
        setState(799);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(800);
      match(detect_type_function::SEPAR);
      setState(804);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(801);
          match(detect_type_function::WS); 
        }
        setState(806);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
      }
      setState(807);
      expr(0);
      setState(811);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(808);
        match(detect_type_function::WS);
        setState(813);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(814);
      match(detect_type_function::Rb);
      setState(818);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(815);
          match(detect_type_function::WS); 
        }
        setState(820);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx);
      }
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(824);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(821);
        match(detect_type_function::WS);
        setState(826);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(827);
      match(detect_type_function::GAMMA);
      setState(828);
      match(detect_type_function::Lb);
      setState(832);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(829);
          match(detect_type_function::WS); 
        }
        setState(834);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
      }
      setState(835);
      expr(0);
      setState(839);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(836);
        match(detect_type_function::WS);
        setState(841);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(842);
      match(detect_type_function::Rb);
      setState(846);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(843);
          match(detect_type_function::WS); 
        }
        setState(848);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx);
      }
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(852);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(849);
        match(detect_type_function::WS);
        setState(854);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(855);
      match(detect_type_function::GAMMA_REV);
      setState(856);
      match(detect_type_function::Lb);
      setState(860);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(857);
          match(detect_type_function::WS); 
        }
        setState(862);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx);
      }
      setState(863);
      expr(0);
      setState(867);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(864);
        match(detect_type_function::WS);
        setState(869);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(870);
      match(detect_type_function::SEPAR);
      setState(874);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(871);
          match(detect_type_function::WS); 
        }
        setState(876);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx);
      }
      setState(877);
      expr(0);
      setState(881);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(878);
        match(detect_type_function::WS);
        setState(883);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(884);
      match(detect_type_function::SEPAR);
      setState(888);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(885);
          match(detect_type_function::WS); 
        }
        setState(890);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
      }
      setState(891);
      expr(0);
      setState(895);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(892);
        match(detect_type_function::WS);
        setState(897);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(898);
      match(detect_type_function::Rb);
      setState(902);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(899);
          match(detect_type_function::WS); 
        }
        setState(904);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiargfunctionContext ------------------------------------------------------------------

detect_type_function::MultiargfunctionContext::MultiargfunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::SUMPRODUCT() {
  return getToken(detect_type_function::SUMPRODUCT, 0);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::Lb() {
  return getToken(detect_type_function::Lb, 0);
}

std::vector<detect_type_function::ExprContext *> detect_type_function::MultiargfunctionContext::expr() {
  return getRuleContexts<detect_type_function::ExprContext>();
}

detect_type_function::ExprContext* detect_type_function::MultiargfunctionContext::expr(size_t i) {
  return getRuleContext<detect_type_function::ExprContext>(i);
}

std::vector<tree::TerminalNode *> detect_type_function::MultiargfunctionContext::SEPAR() {
  return getTokens(detect_type_function::SEPAR);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::SEPAR(size_t i) {
  return getToken(detect_type_function::SEPAR, i);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::Rb() {
  return getToken(detect_type_function::Rb, 0);
}

std::vector<tree::TerminalNode *> detect_type_function::MultiargfunctionContext::WS() {
  return getTokens(detect_type_function::WS);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::WS(size_t i) {
  return getToken(detect_type_function::WS, i);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::SUM() {
  return getToken(detect_type_function::SUM, 0);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::PRODUCT() {
  return getToken(detect_type_function::PRODUCT, 0);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::CONCAT() {
  return getToken(detect_type_function::CONCAT, 0);
}

std::vector<detect_type_function::String_argContext *> detect_type_function::MultiargfunctionContext::string_arg() {
  return getRuleContexts<detect_type_function::String_argContext>();
}

detect_type_function::String_argContext* detect_type_function::MultiargfunctionContext::string_arg(size_t i) {
  return getRuleContext<detect_type_function::String_argContext>(i);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::SEARCH_STRING() {
  return getToken(detect_type_function::SEARCH_STRING, 0);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::CONTAIN_TEXT() {
  return getToken(detect_type_function::CONTAIN_TEXT, 0);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::ROOT_MEAN_SQUARE() {
  return getToken(detect_type_function::ROOT_MEAN_SQUARE, 0);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::ROOT_MEAN_SQUARE_ERROR() {
  return getToken(detect_type_function::ROOT_MEAN_SQUARE_ERROR, 0);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::AVERAGE() {
  return getToken(detect_type_function::AVERAGE, 0);
}

tree::TerminalNode* detect_type_function::MultiargfunctionContext::MEDIAN() {
  return getToken(detect_type_function::MEDIAN, 0);
}


size_t detect_type_function::MultiargfunctionContext::getRuleIndex() const {
  return detect_type_function::RuleMultiargfunction;
}

void detect_type_function::MultiargfunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiargfunction(this);
}

void detect_type_function::MultiargfunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiargfunction(this);
}

detect_type_function::MultiargfunctionContext* detect_type_function::multiargfunction() {
  MultiargfunctionContext *_localctx = _tracker.createInstance<MultiargfunctionContext>(_ctx, getState());
  enterRule(_localctx, 16, detect_type_function::RuleMultiargfunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1125);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(910);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(907);
        match(detect_type_function::WS);
        setState(912);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(913);
      match(detect_type_function::SUMPRODUCT);
      setState(914);
      match(detect_type_function::Lb);
      setState(915);
      expr(0);
      setState(916);
      match(detect_type_function::SEPAR);
      setState(917);
      expr(0);
      setState(922);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(918);
        match(detect_type_function::SEPAR);
        setState(919);
        expr(0);
        setState(924);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(925);
      match(detect_type_function::Rb);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(930);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(927);
        match(detect_type_function::WS);
        setState(932);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(933);
      match(detect_type_function::SUM);
      setState(934);
      match(detect_type_function::Lb);
      setState(935);
      expr(0);
      setState(936);
      match(detect_type_function::SEPAR);
      setState(937);
      expr(0);
      setState(942);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(938);
        match(detect_type_function::SEPAR);
        setState(939);
        expr(0);
        setState(944);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(945);
      match(detect_type_function::Rb);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(950);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(947);
        match(detect_type_function::WS);
        setState(952);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(953);
      match(detect_type_function::PRODUCT);
      setState(954);
      match(detect_type_function::Lb);
      setState(955);
      expr(0);
      setState(956);
      match(detect_type_function::SEPAR);
      setState(957);
      expr(0);
      setState(962);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(958);
        match(detect_type_function::SEPAR);
        setState(959);
        expr(0);
        setState(964);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(965);
      match(detect_type_function::Rb);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(970);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(967);
        match(detect_type_function::WS);
        setState(972);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(973);
      match(detect_type_function::CONCAT);
      setState(974);
      match(detect_type_function::Lb);
      setState(975);
      string_arg();
      setState(976);
      match(detect_type_function::SEPAR);
      setState(977);
      string_arg();
      setState(982);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(978);
        match(detect_type_function::SEPAR);
        setState(979);
        string_arg();
        setState(984);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(985);
      match(detect_type_function::Rb);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(990);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(987);
        match(detect_type_function::WS);
        setState(992);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(993);
      match(detect_type_function::SEARCH_STRING);
      setState(994);
      match(detect_type_function::Lb);
      setState(995);
      string_arg();
      setState(1000);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(996);
        match(detect_type_function::SEPAR);
        setState(997);
        string_arg();
        setState(1002);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1003);
      match(detect_type_function::Rb);
      setState(1007);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1004);
          match(detect_type_function::WS); 
        }
        setState(1009);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx);
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1013);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(1010);
        match(detect_type_function::WS);
        setState(1015);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1016);
      match(detect_type_function::CONTAIN_TEXT);
      setState(1017);
      match(detect_type_function::Lb);
      setState(1018);
      string_arg();
      setState(1023);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(1019);
        match(detect_type_function::SEPAR);
        setState(1020);
        string_arg();
        setState(1025);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1026);
      match(detect_type_function::Rb);
      setState(1030);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1027);
          match(detect_type_function::WS); 
        }
        setState(1032);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx);
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1036);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(1033);
        match(detect_type_function::WS);
        setState(1038);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1039);
      match(detect_type_function::ROOT_MEAN_SQUARE);
      setState(1040);
      match(detect_type_function::Lb);
      setState(1041);
      expr(0);
      setState(1046);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(1042);
        match(detect_type_function::SEPAR);
        setState(1043);
        expr(0);
        setState(1048);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1049);
      match(detect_type_function::Rb);
      setState(1053);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1050);
          match(detect_type_function::WS); 
        }
        setState(1055);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx);
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1059);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(1056);
        match(detect_type_function::WS);
        setState(1061);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1062);
      match(detect_type_function::ROOT_MEAN_SQUARE_ERROR);
      setState(1063);
      match(detect_type_function::Lb);
      setState(1064);
      expr(0);
      setState(1069);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(1065);
        match(detect_type_function::SEPAR);
        setState(1066);
        expr(0);
        setState(1071);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1072);
      match(detect_type_function::Rb);
      setState(1076);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1073);
          match(detect_type_function::WS); 
        }
        setState(1078);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx);
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1082);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(1079);
        match(detect_type_function::WS);
        setState(1084);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1085);
      match(detect_type_function::AVERAGE);
      setState(1086);
      match(detect_type_function::Lb);
      setState(1087);
      expr(0);
      setState(1092);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(1088);
        match(detect_type_function::SEPAR);
        setState(1089);
        expr(0);
        setState(1094);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1095);
      match(detect_type_function::Rb);
      setState(1099);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1096);
          match(detect_type_function::WS); 
        }
        setState(1101);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx);
      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1105);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(1102);
        match(detect_type_function::WS);
        setState(1107);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1108);
      match(detect_type_function::MEDIAN);
      setState(1109);
      match(detect_type_function::Lb);
      setState(1110);
      expr(0);
      setState(1115);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(1111);
        match(detect_type_function::SEPAR);
        setState(1112);
        expr(0);
        setState(1117);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1118);
      match(detect_type_function::Rb);
      setState(1122);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1119);
          match(detect_type_function::WS); 
        }
        setState(1124);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RangefunctionContext ------------------------------------------------------------------

detect_type_function::RangefunctionContext::RangefunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::RangefunctionContext::SUM_I() {
  return getToken(detect_type_function::SUM_I, 0);
}

tree::TerminalNode* detect_type_function::RangefunctionContext::Lb() {
  return getToken(detect_type_function::Lb, 0);
}

detect_type_function::ExprContext* detect_type_function::RangefunctionContext::expr() {
  return getRuleContext<detect_type_function::ExprContext>(0);
}

tree::TerminalNode* detect_type_function::RangefunctionContext::Rb() {
  return getToken(detect_type_function::Rb, 0);
}

std::vector<tree::TerminalNode *> detect_type_function::RangefunctionContext::WS() {
  return getTokens(detect_type_function::WS);
}

tree::TerminalNode* detect_type_function::RangefunctionContext::WS(size_t i) {
  return getToken(detect_type_function::WS, i);
}

tree::TerminalNode* detect_type_function::RangefunctionContext::PRODUCT_I() {
  return getToken(detect_type_function::PRODUCT_I, 0);
}

std::vector<tree::TerminalNode *> detect_type_function::RangefunctionContext::SEPAR() {
  return getTokens(detect_type_function::SEPAR);
}

tree::TerminalNode* detect_type_function::RangefunctionContext::SEPAR(size_t i) {
  return getToken(detect_type_function::SEPAR, i);
}

std::vector<detect_type_function::VariableContext *> detect_type_function::RangefunctionContext::variable() {
  return getRuleContexts<detect_type_function::VariableContext>();
}

detect_type_function::VariableContext* detect_type_function::RangefunctionContext::variable(size_t i) {
  return getRuleContext<detect_type_function::VariableContext>(i);
}

std::vector<tree::TerminalNode *> detect_type_function::RangefunctionContext::UINT() {
  return getTokens(detect_type_function::UINT);
}

tree::TerminalNode* detect_type_function::RangefunctionContext::UINT(size_t i) {
  return getToken(detect_type_function::UINT, i);
}


size_t detect_type_function::RangefunctionContext::getRuleIndex() const {
  return detect_type_function::RuleRangefunction;
}

void detect_type_function::RangefunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRangefunction(this);
}

void detect_type_function::RangefunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRangefunction(this);
}

detect_type_function::RangefunctionContext* detect_type_function::rangefunction() {
  RangefunctionContext *_localctx = _tracker.createInstance<RangefunctionContext>(_ctx, getState());
  enterRule(_localctx, 18, detect_type_function::RuleRangefunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1220);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1130);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(1127);
        match(detect_type_function::WS);
        setState(1132);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1133);
      match(detect_type_function::SUM_I);
      setState(1134);
      match(detect_type_function::Lb);
      setState(1138);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1135);
          match(detect_type_function::WS); 
        }
        setState(1140);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      }
      setState(1141);
      expr(0);
      setState(1145);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(1142);
        match(detect_type_function::WS);
        setState(1147);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1148);
      match(detect_type_function::Rb);
      setState(1152);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1149);
          match(detect_type_function::WS); 
        }
        setState(1154);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1158);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(1155);
        match(detect_type_function::WS);
        setState(1160);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1161);
      match(detect_type_function::PRODUCT_I);
      setState(1162);
      match(detect_type_function::Lb);
      setState(1166);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1163);
          match(detect_type_function::WS); 
        }
        setState(1168);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
      }
      setState(1169);
      expr(0);
      setState(1173);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::WS) {
        setState(1170);
        match(detect_type_function::WS);
        setState(1175);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1210);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == detect_type_function::SEPAR) {
        setState(1176);
        match(detect_type_function::SEPAR);
        setState(1180);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1177);
            match(detect_type_function::WS); 
          }
          setState(1182);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
        }
        setState(1183);
        variable();
        setState(1198); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1187);
                  _errHandler->sync(this);
                  _la = _input->LA(1);
                  while (_la == detect_type_function::WS) {
                    setState(1184);
                    match(detect_type_function::WS);
                    setState(1189);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                  }
                  setState(1190);
                  match(detect_type_function::SEPAR);
                  setState(1191);
                  match(detect_type_function::UINT);
                  setState(1195);
                  _errHandler->sync(this);
                  alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
                  while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                    if (alt == 1) {
                      setState(1192);
                      match(detect_type_function::WS); 
                    }
                    setState(1197);
                    _errHandler->sync(this);
                    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
                  }
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1200); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(1205);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == detect_type_function::WS) {
          setState(1202);
          match(detect_type_function::WS);
          setState(1207);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1212);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1213);
      match(detect_type_function::Rb);
      setState(1217);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1214);
          match(detect_type_function::WS); 
        }
        setState(1219);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringContext ------------------------------------------------------------------

detect_type_function::StringContext::StringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::StringContext::STRING() {
  return getToken(detect_type_function::STRING, 0);
}


size_t detect_type_function::StringContext::getRuleIndex() const {
  return detect_type_function::RuleString;
}

void detect_type_function::StringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterString(this);
}

void detect_type_function::StringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitString(this);
}

detect_type_function::StringContext* detect_type_function::string() {
  StringContext *_localctx = _tracker.createInstance<StringContext>(_ctx, getState());
  enterRule(_localctx, 20, detect_type_function::RuleString);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1222);
    match(detect_type_function::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_argContext ------------------------------------------------------------------

detect_type_function::String_argContext::String_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* detect_type_function::String_argContext::STRING_ARG() {
  return getToken(detect_type_function::STRING_ARG, 0);
}


size_t detect_type_function::String_argContext::getRuleIndex() const {
  return detect_type_function::RuleString_arg;
}

void detect_type_function::String_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterString_arg(this);
}

void detect_type_function::String_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<detect_type_functionListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitString_arg(this);
}

detect_type_function::String_argContext* detect_type_function::string_arg() {
  String_argContext *_localctx = _tracker.createInstance<String_argContext>(_ctx, getState());
  enterRule(_localctx, 22, detect_type_function::RuleString_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1224);
    match(detect_type_function::STRING_ARG);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool detect_type_function::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 4: return exprSempred(antlrcpp::downCast<ExprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool detect_type_function::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 3);
    case 1: return precpred(_ctx, 2);
    case 2: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void detect_type_function::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  detect_type_functionParserInitialize();
#else
  ::antlr4::internal::call_once(detect_type_functionParserOnceFlag, detect_type_functionParserInitialize);
#endif
}
